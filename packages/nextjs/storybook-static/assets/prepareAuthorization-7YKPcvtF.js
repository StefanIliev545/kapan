import{C as G,o as $,A as O,p as H,B as v,q as N,r as J,t as K,L as Q,v as q,w as E,e as z,x as S,y as L,z as V,D as X,E as k,b as Y}from"./createSafeContext-Dp97sAkz.js";import{e as Z,g as T,h as j,p as tt,j as et,k as at,m as B,n as st,U as nt,A as rt,o as ot,q as it,t as ct,v as ut,x as dt,i as lt}from"./en_US-YBXRRIY6-ByhZuFgc.js";function ft({chain:t,currentChainId:e}){if(!t)throw new G;if(e!==t.id)throw new $({chain:t,currentChainId:e})}const F=new Q(128);async function pt(t,e){const{account:l=t.account,chain:f=t.chain,accessList:h,authorizationList:p,blobs:w,data:o,gas:y,gasPrice:C,maxFeePerBlobGas:a,maxFeePerGas:g,maxPriorityFeePerGas:c,nonce:s,type:i,value:u,...d}=e;if(typeof l>"u")throw new O({docsPath:"/docs/actions/wallet/sendTransaction"});const n=l?N(l):null;try{H(e);const r=await(async()=>{if(e.to)return e.to;if(e.to!==null&&p&&p.length>0)return await Z({authorization:p[0]}).catch(()=>{throw new v("`to` is required. Could not infer from `authorizationList`.")})})();if(n?.type==="json-rpc"||n===null){let m;f!==null&&(m=await T(t,j,"getChainId")({}),ft({currentChainId:m,chain:f}));const x=t.chain?.formatters?.transactionRequest?.format,P=(x||J)({...K(d,{format:x}),accessList:h,account:n,authorizationList:p,blobs:w,chainId:m,data:o,gas:y,gasPrice:C,maxFeePerBlobGas:a,maxFeePerGas:g,maxPriorityFeePerGas:c,nonce:s,to:r,type:i,value:u},"sendTransaction"),_=F.get(t.uid),W=_?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:W,params:[P]},{retryCount:0})}catch(M){if(_===!1)throw M;const b=M;if(b.name==="InvalidInputRpcError"||b.name==="InvalidParamsRpcError"||b.name==="MethodNotFoundRpcError"||b.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[P]},{retryCount:0}).then(I=>(F.set(t.uid,!0),I)).catch(I=>{const R=I;throw R.name==="MethodNotFoundRpcError"||R.name==="MethodNotSupportedRpcError"?(F.set(t.uid,!1),b):R});throw b}}if(n?.type==="local"){const m=await T(t,tt,"prepareTransactionRequest")({account:n,accessList:h,authorizationList:p,blobs:w,chain:f,data:o,gas:y,gasPrice:C,maxFeePerBlobGas:a,maxFeePerGas:g,maxPriorityFeePerGas:c,nonce:s,nonceManager:n.nonceManager,parameters:[...et,"sidecars"],type:i,value:u,...d,to:r}),x=f?.serializers?.transaction,A=await n.signTransaction(m,{serializer:x});return await T(t,at,"sendRawTransaction")({serializedTransaction:A})}throw n?.type==="smart"?new q({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new q({docsPath:"/docs/actions/wallet/sendTransaction",type:n?.type})}catch(r){throw r instanceof q?r:B(r,{...e,account:n,chain:e.chain||void 0})}}class ht extends v{constructor(e){super(`Call bundle failed with status: ${e.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=e}}const U="0x5792579257925792579257925792579257925792579257925792579257925792",D=E(0,{size:32});async function Ct(t,e){const{account:l=t.account,capabilities:f,chain:h=t.chain,experimental_fallback:p,experimental_fallbackDelay:w=32,forceAtomic:o=!1,id:y,version:C="2.0.0"}=e,a=l?N(l):null,g=e.calls.map(c=>{const s=c,i=s.abi?st({abi:s.abi,functionName:s.functionName,args:s.args}):s.data;return{data:s.dataSuffix&&i?z([i,s.dataSuffix]):i,to:s.to,value:s.value?E(s.value):void 0}});try{const c=await t.request({method:"wallet_sendCalls",params:[{atomicRequired:o,calls:g,capabilities:f,chainId:E(h.id),from:a?.address,id:y,version:C}]},{retryCount:0});return typeof c=="string"?{id:c}:c}catch(c){const s=c;if(p&&(s.name==="MethodNotFoundRpcError"||s.name==="MethodNotSupportedRpcError"||s.name==="UnknownRpcError"||s.details.toLowerCase().includes("does not exist / is not available")||s.details.toLowerCase().includes("missing or invalid. request()")||s.details.toLowerCase().includes("did not match any variant of untagged enum")||s.details.toLowerCase().includes("account upgraded to unsupported contract")||s.details.toLowerCase().includes("eip-7702 not supported")||s.details.toLowerCase().includes("unsupported wc_ method")||s.details.toLowerCase().includes("feature toggled misconfigured")||s.details.toLowerCase().includes("jsonrpcengine: response has no error or result for request"))){if(f&&Object.values(f).some(r=>!r.optional)){const r="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new nt(new v(r,{details:r}))}if(o&&g.length>1){const n="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new rt(new v(n,{details:n}))}const i=[];for(const n of g){const r=pt(t,{account:a,chain:h,data:n.data,to:n.to,value:n.value?S(n.value):void 0});i.push(r),w>0&&await new Promise(m=>setTimeout(m,w))}const u=await Promise.allSettled(i);if(u.every(n=>n.status==="rejected"))throw u[0].reason;const d=u.map(n=>n.status==="fulfilled"?n.value:D);return{id:z([...d,E(h.id,{size:32}),U])}}throw B(c,{...e,account:a,chain:e.chain})}}async function wt(t,e){async function l(a){if(a.endsWith(U.slice(2))){const c=X(k(a,-64,-32)),s=k(a,0,-64).slice(2).match(/.{1,64}/g),i=await Promise.all(s.map(d=>D.slice(2)!==d?t.request({method:"eth_getTransactionReceipt",params:[`0x${d}`]},{dedupe:!0}):void 0)),u=i.some(d=>d===null)?100:i.every(d=>d?.status==="0x1")?200:i.every(d=>d?.status==="0x0")?500:600;return{atomic:!1,chainId:L(c),receipts:i.filter(Boolean),status:u,version:"2.0.0"}}return t.request({method:"wallet_getCallsStatus",params:[a]})}const{atomic:f=!1,chainId:h,receipts:p,version:w="2.0.0",...o}=await l(e.id),[y,C]=(()=>{const a=o.status;return a>=100&&a<200?["pending",a]:a>=200&&a<300?["success",a]:a>=300&&a<700?["failure",a]:a==="CONFIRMED"?["success",200]:a==="PENDING"?["pending",100]:[void 0,a]})();return{...o,atomic:f,chainId:h?L(h):void 0,receipts:p?.map(a=>({...a,blockNumber:S(a.blockNumber),gasUsed:S(a.gasUsed),status:V[a.status]}))??[],statusCode:C,status:y,version:w}}async function bt(t,e){const{id:l,pollingInterval:f=t.pollingInterval,status:h=({statusCode:u})=>u===200||u>=300,retryCount:p=4,retryDelay:w=({count:u})=>~~(1<<u)*200,timeout:o=6e4,throwOnFailure:y=!1}=e,C=Y(["waitForCallsStatus",t.uid,l]),{promise:a,resolve:g,reject:c}=ot();let s;const i=it(C,{resolve:g,reject:c},u=>{const d=ct(async()=>{const n=r=>{clearTimeout(s),d(),r(),i()};try{const r=await ut(async()=>{const m=await T(t,wt,"getCallsStatus")({id:l});if(y&&m.status==="failure")throw new ht(m);return m},{retryCount:p,delay:w});if(!h(r))return;n(()=>u.resolve(r))}catch(r){n(()=>u.reject(r))}},{interval:f,emitOnBegin:!0});return d});return s=o?setTimeout(()=>{i(),clearTimeout(s),c(new mt({id:l}))},o):void 0,await a}class mt extends v{constructor({id:e}){super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}async function Tt(t,e){const{account:l=t.account,chainId:f,nonce:h}=e;if(!l)throw new O({docsPath:"/docs/eip7702/prepareAuthorization"});const p=N(l),w=(()=>{if(e.executor)return e.executor==="self"?e.executor:N(e.executor)})(),o={address:e.contractAddress??e.address,chainId:f,nonce:h};return typeof o.chainId>"u"&&(o.chainId=t.chain?.id??await T(t,j,"getChainId")({})),typeof o.nonce>"u"&&(o.nonce=await T(t,dt,"getTransactionCount")({address:p.address,blockTag:"pending"}),(w==="self"||w?.address&&lt(w.address,p.address))&&(o.nonce+=1)),o}export{pt as a,ft as b,wt as g,Tt as p,Ct as s,bt as w};
