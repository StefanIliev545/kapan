#!/usr/bin/env node
/**
 * Deduplicates ABIs in deployedContracts.ts
 *
 * Same contracts deployed on multiple chains repeat their full ABI each time.
 * This script extracts unique ABIs into shared constants, cutting the file size
 * dramatically and fixing OOM during Next.js builds.
 *
 * Usage: node scripts/dedup-contracts.mjs
 */

import { readFileSync, writeFileSync } from "fs";
import { createHash } from "crypto";
import { fileURLToPath } from "url";
import { dirname, join } from "path";

const __dirname = dirname(fileURLToPath(import.meta.url));
const contractsPath = join(__dirname, "../contracts/hardhat/deployedContracts.ts");

const raw = readFileSync(contractsPath, "utf-8");

// Strip TS-only syntax so we can eval it as JS
const jsContent = raw
  .replace(/^import.*$/gm, "")
  .replace(/} as const;/, "};")
  .replace(/export default.*$/gm, "")
  .replace(/satisfies\s+\w+/g, "")
  .replace("const contracts =", "var __contracts =");

const fn = new Function(`${jsContent}; return __contracts;`);
const contracts = fn();

// Collect all unique ABIs by hash
// hash -> { name (first contract name seen), abi }
const abiByHash = new Map();
// Track per-contract-entry which hash it uses
// "chainId:contractName" -> hash
const entryHashes = new Map();

for (const [chainId, chainContracts] of Object.entries(contracts)) {
  for (const [name, contract] of Object.entries(chainContracts)) {
    const abiJson = JSON.stringify(contract.abi);
    const hash = createHash("sha256").update(abiJson).digest("hex").slice(0, 8);

    if (!abiByHash.has(hash)) {
      abiByHash.set(hash, { name, abi: contract.abi });
    }
    entryHashes.set(`${chainId}:${name}`, hash);
  }
}

// Build hash -> unique variable name
// Group by contract name. If a contract name maps to exactly one hash, use "ContractNameAbi".
// If it maps to multiple hashes (different ABI versions), suffix with version number.
const nameToHashes = new Map();
for (const { name } of abiByHash.values()) {
  if (!nameToHashes.has(name)) nameToHashes.set(name, new Set());
}
for (const [, hash] of entryHashes) {
  const { name } = abiByHash.get(hash);
  nameToHashes.get(name).add(hash);
}

const hashToVar = new Map();
for (const [name, hashes] of nameToHashes) {
  const sorted = [...hashes];
  if (sorted.length === 1) {
    hashToVar.set(sorted[0], `${name}Abi`);
  } else {
    sorted.forEach((h, i) => {
      hashToVar.set(h, `${name}Abi_v${i + 1}`);
    });
  }
}

// Some hashes come from contracts where the "first seen name" differs but the ABI is identical.
// Make sure every hash has a variable name.
for (const hash of abiByHash.keys()) {
  if (!hashToVar.has(hash)) {
    const { name } = abiByHash.get(hash);
    hashToVar.set(hash, `${name}Abi`);
  }
}

// Generate the output file
const lines = [];
lines.push(`/**`);
lines.push(` * This file is autogenerated by Scaffold-ETH.`);
lines.push(` * You should not edit it manually or your changes might be overwritten.`);
lines.push(` */`);
lines.push(``);
lines.push(`import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";`);
lines.push(``);
lines.push(`// ---- Shared ABIs (deduplicated) ----`);
lines.push(``);

// Emit each unique ABI once
for (const [hash, varName] of hashToVar.entries()) {
  const { abi } = abiByHash.get(hash);
  lines.push(`const ${varName} = ${JSON.stringify(abi, null, 2)} as const;`);
  lines.push(``);
}

lines.push(`// ---- Deployed contracts per chain ----`);
lines.push(``);
lines.push(`const contracts = {`);

const chainIds = Object.keys(contracts).sort((a, b) => Number(a) - Number(b));

for (const chainId of chainIds) {
  lines.push(`  ${chainId}: {`);
  const chainContracts = contracts[chainId];

  for (const [name, contract] of Object.entries(chainContracts)) {
    const hash = entryHashes.get(`${chainId}:${name}`);
    const varName = hashToVar.get(hash);

    lines.push(`    ${name}: {`);
    lines.push(`      address: ${JSON.stringify(contract.address)},`);
    lines.push(`      abi: ${varName},`);
    if (contract.inheritedFunctions && Object.keys(contract.inheritedFunctions).length > 0) {
      lines.push(`      inheritedFunctions: ${JSON.stringify(contract.inheritedFunctions)},`);
    } else {
      lines.push(`      inheritedFunctions: {},`);
    }
    lines.push(`    },`);
  }

  lines.push(`  },`);
}

lines.push(`} as const;`);
lines.push(``);
lines.push(`export default contracts satisfies GenericContractsDeclaration;`);
lines.push(``);

const output = lines.join("\n");
writeFileSync(contractsPath, output);

const oldSize = raw.length;
const newSize = output.length;
const oldLines = raw.split("\n").length;
const newLines = output.split("\n").length;

console.log(`Deduplicated deployedContracts.ts`);
console.log(`  Unique ABIs: ${abiByHash.size} (from ${entryHashes.size} contract entries)`);
console.log(`  Lines: ${oldLines} -> ${newLines} (${Math.round((1 - newLines / oldLines) * 100)}% reduction)`);
console.log(`  Size: ${(oldSize / 1024).toFixed(0)}KB -> ${(newSize / 1024).toFixed(0)}KB (${Math.round((1 - newSize / oldSize) * 100)}% reduction)`);
