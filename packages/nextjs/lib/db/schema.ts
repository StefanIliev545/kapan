import { pgTable, uuid, text, timestamp, index, integer, numeric, pgEnum } from "drizzle-orm/pg-core";

/**
 * Referral codes generated by users
 */
export const referralCodes = pgTable(
  "referral_codes",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    walletAddress: text("wallet_address").notNull(),
    code: text("code").notNull().unique(),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  },
  (table) => [
    index("idx_referral_codes_wallet").on(table.walletAddress),
    index("idx_referral_codes_code").on(table.code),
  ]
);

/**
 * Referral relationships (who referred whom)
 */
export const referrals = pgTable(
  "referrals",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    referrerAddress: text("referrer_address").notNull(),
    refereeAddress: text("referee_address").notNull(),
    referralCode: text("referral_code").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  },
  (table) => [
    index("idx_referrals_referrer").on(table.referrerAddress),
    index("idx_referrals_referee").on(table.refereeAddress),
  ]
);

// ============ Order Types ============

export const orderTypeEnum = pgEnum("order_type", [
  "collateral_swap",
  "debt_swap",
  "leverage_up",
  "close_position",
  "unknown",
]);

export const orderStatusEnum = pgEnum("order_status", [
  "pending",
  "open",
  "partially_filled",
  "filled",
  "cancelled",
  "expired",
]);

// ============ Orders ============

/**
 * CoW Protocol order history
 */
export const orders = pgTable(
  "orders",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    // Order identifiers
    orderUid: text("order_uid").notNull().unique(), // CoW order UID
    orderHash: text("order_hash"), // On-chain order hash (if available)
    salt: text("salt"), // Order salt for lookup

    // User & chain
    userAddress: text("user_address").notNull(),
    chainId: integer("chain_id").notNull(),

    // Order type & protocol
    orderType: orderTypeEnum("order_type").notNull().default("unknown"),
    protocol: text("protocol"), // aave, morpho, compound, venus

    // Tokens
    sellToken: text("sell_token").notNull(),
    buyToken: text("buy_token").notNull(),
    sellTokenSymbol: text("sell_token_symbol"),
    buyTokenSymbol: text("buy_token_symbol"),

    // Amounts (stored as strings to preserve precision)
    sellAmount: numeric("sell_amount", { precision: 78, scale: 0 }).notNull(),
    buyAmount: numeric("buy_amount", { precision: 78, scale: 0 }).notNull(),
    filledSellAmount: numeric("filled_sell_amount", { precision: 78, scale: 0 }).default("0"),
    filledBuyAmount: numeric("filled_buy_amount", { precision: 78, scale: 0 }).default("0"),

    // Status
    status: orderStatusEnum("status").notNull().default("pending"),

    // Timestamps
    validTo: timestamp("valid_to", { withTimezone: true }), // Order expiry
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
  },
  (table) => [
    index("idx_orders_user").on(table.userAddress),
    index("idx_orders_user_chain").on(table.userAddress, table.chainId),
    index("idx_orders_status").on(table.status),
    index("idx_orders_order_uid").on(table.orderUid),
  ]
);

// ============ Bridges ============

export const bridgeStatusEnum = pgEnum("bridge_status", ["pending", "done", "failed"]);

/**
 * Bridge transaction history (LI.FI widget routes).
 * Primary source of truth â€” localStorage in bridgeHistory.ts acts as write-through cache.
 */
export const bridges = pgTable(
  "bridges",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    routeId: text("route_id").notNull().unique(),
    userAddress: text("user_address").notNull(),
    fromChainId: integer("from_chain_id").notNull(),
    toChainId: integer("to_chain_id").notNull(),
    fromTokenSymbol: text("from_token_symbol").notNull(),
    toTokenSymbol: text("to_token_symbol").notNull(),
    fromTokenLogoUri: text("from_token_logo_uri"),
    toTokenLogoUri: text("to_token_logo_uri"),
    fromAmount: text("from_amount").notNull(),
    toAmount: text("to_amount").notNull(),
    fromAmountUsd: text("from_amount_usd"),
    toAmountUsd: text("to_amount_usd"),
    sendingTxHash: text("sending_tx_hash"),
    sendingTxLink: text("sending_tx_link"),
    receivingTxHash: text("receiving_tx_hash"),
    receivingTxLink: text("receiving_tx_link"),
    status: bridgeStatusEnum("status").notNull().default("pending"),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
    completedAt: timestamp("completed_at", { withTimezone: true }),
    updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
  },
  table => [
    index("idx_bridges_user").on(table.userAddress),
    index("idx_bridges_user_status").on(table.userAddress, table.status),
    index("idx_bridges_route_id").on(table.routeId),
  ],
);

// ============ Order Fills ============

/**
 * Individual order fills (for tracking partial fills)
 */
export const orderFills = pgTable(
  "order_fills",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    orderId: uuid("order_id").notNull().references(() => orders.id, { onDelete: "cascade" }),

    // Fill details
    txHash: text("tx_hash").notNull(),
    fillSellAmount: numeric("fill_sell_amount", { precision: 78, scale: 0 }).notNull(),
    fillBuyAmount: numeric("fill_buy_amount", { precision: 78, scale: 0 }).notNull(),

    // Price at fill (buyAmount / sellAmount)
    executionPrice: numeric("execution_price", { precision: 38, scale: 18 }),

    // Timestamps
    filledAt: timestamp("filled_at", { withTimezone: true }).defaultNow(),
  },
  (table) => [
    index("idx_order_fills_order").on(table.orderId),
    index("idx_order_fills_tx").on(table.txHash),
  ]
);
