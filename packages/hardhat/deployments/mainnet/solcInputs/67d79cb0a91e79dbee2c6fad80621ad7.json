{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/venus/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./VTokenInterface.sol\";\n\n/**\n * @title Venus's Comptroller Interface\n * @notice Interface for interacting with Venus Comptroller\n * @dev Adapted for compatibility with Solidity ^0.8.10 from Venus v4 documentation\n * @dev Source: https://docs-v4.venus.io/technical-reference/reference-core-pool/comptroller/diamond/facets/market-facet\n */\ninterface ComptrollerInterface {\n    /**\n     * @notice Indicator that this is a Comptroller contract (for inspection)\n     */\n    function isComptroller() external pure returns (bool);\n    \n    /**\n     * @notice Enters a list of markets (vTokens)\n     * @param vTokens The list of addresses of the vToken markets to enter\n     * @return success A list of error codes (0=success, otherwise a failure)\n     */\n    function enterMarkets(address[] calldata vTokens) external returns (uint[] memory);\n    \n    /**\n     * @notice Exits a vToken market\n     * @param vTokenAddress Address of the vToken market to exit\n     * @return success 0=success, otherwise a failure\n     */\n    function exitMarket(address vTokenAddress) external returns (uint);\n    \n    /**\n     * @notice Returns the list of vToken markets an account has entered\n     * @param account The address of the account to query\n     * @return The list of vToken markets the account has entered\n     */\n    function getAssetsIn(address account) external view returns (VTokenInterface[] memory);\n    \n    /**\n     * @notice Checks if an account is entered into a specific market\n     * @param account The address of the account to check\n     * @param vToken The vToken market to check\n     * @return True if the account is in the market, otherwise false\n     */\n    function checkMembership(address account, address vToken) external view returns (bool);\n    \n    /**\n     * @notice Returns a list of all vToken markets\n     * @return A list of all vToken market addresses\n     */\n    function getAllMarkets() external view returns (VTokenInterface[] memory);\n    \n    /**\n     * @notice Determine the amount of vToken that could be seized in a liquidation\n     * @param vTokenBorrowed The borrowed vToken\n     * @param vTokenCollateral The collateral vToken\n     * @param actualRepayAmount The amount of vTokenBorrowed underlying to repay\n     * @return errorCode 0=success, otherwise a failure\n     * @return seizeTokens The number of vTokenCollateral tokens to seize\n     */\n    function liquidateCalculateSeizeTokens(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        uint actualRepayAmount\n    ) external view returns (uint, uint);\n    \n    /**\n     * @notice Calculate amount of tokens to seize in a VAI liquidation\n     * @param vTokenCollateral The collateral vToken\n     * @param actualRepayAmount The amount of VAI to repay\n     * @return errorCode 0=success, otherwise a failure\n     * @return seizeTokens The number of vTokenCollateral tokens to seize\n     */\n    function liquidateVAICalculateSeizeTokens(address vTokenCollateral, uint actualRepayAmount) external view returns (uint, uint);\n    \n    /**\n     * @notice Update delegate status to allow/disallow borrowing on behalf\n     * @param delegate The delegate address\n     * @param allowBorrows Whether to allow the delegate to borrow\n     */\n    function updateDelegate(address delegate, bool allowBorrows) external;\n    \n    function approvedDelegates(address user, address delegate) external view returns (bool);\n    \n    /**\n     * @notice Return information about a specific market\n     * @dev On Venus v4 core pool, the third value is the liquidation threshold,\n     *      NOT an \"isComped\" flag as on some older Comptroller variants.\n     * @param vToken The vToken address to get market data for\n     * @return isListed Whether the market is listed\n     * @return collateralFactorMantissa The collateral factor (LTV) for the market (scaled by 1e18)\n     * @return liquidationThresholdMantissa The liquidation threshold (LLTV) for the market (scaled by 1e18)\n     */\n    function markets(address vToken)\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            uint256 liquidationThresholdMantissa\n        );\n    \n    /**\n     * @notice Get the account liquidity information\n     * @param account The address of the account\n     * @return error Error code (0=success, otherwise a failure)\n     * @return liquidity The USD value borrowable by the account\n     * @return shortfall The USD value of collateral needed to meet obligations\n     */\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint);\n    \n    /**\n     * @notice Check if a specific action is allowed\n     * @param vToken The vToken market to check\n     * @param action The action to check (mint=1, redeem=2, borrow=3, repay=4, etc.)\n     * @return True if the action is allowed\n     */\n    function actionAllowed(address vToken, uint8 action) external view returns (bool);\n    \n    /**\n     * @notice Checks if a borrow is allowed\n     * @param vToken The vToken market to check\n     * @param borrower The account borrowing\n     * @param borrowAmount The amount of underlying to borrow\n     * @return 0=success, otherwise a failure\n     */\n    function borrowAllowed(address vToken, address borrower, uint borrowAmount) external returns (uint);\n    \n    /**\n     * @notice Checks if a mint is allowed\n     * @param vToken The vToken market to check\n     * @param minter The account minting\n     * @param mintAmount The amount of underlying to mint\n     * @return 0=success, otherwise a failure\n     */\n    function mintAllowed(address vToken, address minter, uint mintAmount) external returns (uint);\n    \n    /**\n     * @notice Checks if a redeem is allowed\n     * @param vToken The vToken market to check\n     * @param redeemer The account redeeming\n     * @param redeemTokens The amount of vTokens to redeem\n     * @return 0=success, otherwise a failure\n     */\n    function redeemAllowed(address vToken, address redeemer, uint redeemTokens) external returns (uint);\n    \n    /**\n     * @notice Checks if a repay is allowed\n     * @param vToken The vToken market to check\n     * @param payer The account paying\n     * @param borrower The account having their loan repaid\n     * @param repayAmount The amount of underlying to repay\n     * @return 0=success, otherwise a failure\n     */\n    function repayBorrowAllowed(address vToken, address payer, address borrower, uint repayAmount) external returns (uint);\n\n    /**\n     * @notice Returns the price oracle used by the comptroller\n     * @return The address of the oracle\n     */\n    function oracle() external view returns (address);\n}\n"
    },
    "contracts/interfaces/venus/ResilientOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ninterface OracleInterface {\n    function getPrice(address asset) external view returns (uint256);\n}\n\ninterface ResilientOracleInterface is OracleInterface {\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\n}"
    },
    "contracts/interfaces/venus/VTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n/**\n * @title Venus's VToken Interface\n * @notice Interface for interacting with Venus VTokens\n * @dev Adapted for compatibility with Solidity ^0.8.10 from Venus documentation\n */\ninterface VTokenInterface {\n    /*** Market Events ***/\n    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n    event Mint(address minter, uint mintAmount, uint mintTokens);\n    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n    event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n    event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address vTokenCollateral, uint seizeTokens);\n    \n    /*** VToken State ***/\n    function underlying() external view returns (address);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function totalBorrows() external view returns (uint);\n    function totalReserves() external view returns (uint);\n    function exchangeRateStored() external view returns (uint);\n    function accrualBlockNumber() external view returns (uint);\n    function comptroller() external view returns (address);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function reserveFactorMantissa() external view returns (uint);\n    function getCash() external view returns (uint);\n    function borrowIndex() external view returns (uint);\n    \n    /*** User Account Functions ***/\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n    function transfer(address dst, uint amount) external returns (bool);\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    \n    /*** VToken Market Functions ***/\n    function mint(uint mintAmount) external returns (uint);\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function borrow(uint borrowAmount) external returns (uint);\n    function borrowBehalf(address borrower, uint borrowAmount) external returns (uint);\n    function repayBorrow(uint repayAmount) external returns (uint);\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\n    \n    /*** Borrow-Related Functions ***/\n    function borrowBalanceCurrent(address account) external returns (uint);\n    function borrowBalanceStored(address account) external view returns (uint);\n    function supplyRatePerBlock() external view returns (uint);\n    function borrowRatePerBlock() external view returns (uint);\n    function exchangeRateCurrent() external returns (uint);\n    function accrueInterest() external returns (uint);\n    \n    /*** Liquidation Functions ***/\n    function liquidateBorrow(address borrower, uint repayAmount, address vTokenCollateral) external returns (uint);\n    \n    /*** Admin Functions ***/\n    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint);\n    function _reduceReserves(uint reduceAmount) external returns (uint);\n    function _setInterestRateModel(address newInterestRateModel) external returns (uint);\n} "
    },
    "contracts/v2/gateways/venus/VenusGatewayView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ComptrollerInterface} from \"../../../interfaces/venus/ComptrollerInterface.sol\";\nimport {VTokenInterface} from \"../../../interfaces/venus/VTokenInterface.sol\";\nimport {ResilientOracleInterface} from \"../../../interfaces/venus/ResilientOracleInterface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title VenusGatewayView\n * @notice View-only gateway for Venus protocol\n * @dev Contains all read/view functions from v1, separate from write operations\n */\ncontract VenusGatewayView is Ownable {\n    ComptrollerInterface public comptroller;\n    ResilientOracleInterface public oracle;\n\n    constructor(address _comptroller, address _oracle, address owner_) Ownable(owner_) {\n        comptroller = ComptrollerInterface(_comptroller);\n        oracle = ResilientOracleInterface(_oracle);\n    }\n    \n    function setComptroller(address _comptroller) external onlyOwner {\n        comptroller = ComptrollerInterface(_comptroller);\n    }\n\n    function setOracle(address _oracle) external onlyOwner {\n        oracle = ResilientOracleInterface(_oracle);\n    }\n\n    function getVTokenForUnderlying(address underlyingToken) public view returns (address) {\n        address[] memory vTokenAddresses = this.getAllMarkets();\n        \n        for (uint i = 0; i < vTokenAddresses.length; i++) {\n            address vTokenAddress = vTokenAddresses[i];\n            \n            try VTokenInterface(vTokenAddress).underlying() returns (address underlying) {\n                if (underlying == underlyingToken) {\n                    return vTokenAddress;\n                }\n            } catch {\n                // Skip if there's an error (e.g., for vBNB which might not have an underlying() function)\n                continue;\n            }\n        }\n        \n        revert(\"VenusGateway: vToken not found for underlying token\");\n    }\n    \n    function getAssetsIn(address account) external view returns (address[] memory) {\n        VTokenInterface[] memory vTokens = comptroller.getAssetsIn(account);\n        address[] memory vTokenAddresses = new address[](vTokens.length);\n        \n        for (uint i = 0; i < vTokens.length; i++) {\n            vTokenAddresses[i] = address(vTokens[i]);\n        }\n        \n        return vTokenAddresses;\n    }\n    \n    function checkMembership(address account, address vToken) external view returns (bool) {\n        return comptroller.checkMembership(account, vToken);\n    }\n    \n    function getAllMarkets() external view returns (address[] memory) {\n        VTokenInterface[] memory vTokens = comptroller.getAllMarkets();\n        address[] memory vTokenAddresses = new address[](vTokens.length);\n        \n        for (uint i = 0; i < vTokens.length; i++) {\n            vTokenAddresses[i] = address(vTokens[i]);\n        }\n        \n        return vTokenAddresses;\n    }\n    \n    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n        return comptroller.getAccountLiquidity(account);\n    }\n    \n    function getBalance(address token, address user) external view returns (uint256) {\n        address vTokenAddress = getVTokenForUnderlying(token);\n        \n        // Get vToken balance\n        uint vTokenBalance = VTokenInterface(vTokenAddress).balanceOf(user);\n        \n        // Convert to underlying amount using exchange rate\n        uint exchangeRate = VTokenInterface(vTokenAddress).exchangeRateStored();\n        \n        // Calculate underlying value\n        return (vTokenBalance * exchangeRate) / 1e18;\n    }\n    \n    function getBorrowBalance(address token, address user) external view returns (uint256) {\n        address vTokenAddress = getVTokenForUnderlying(token);\n        return VTokenInterface(vTokenAddress).borrowBalanceStored(user);\n    }\n\n    function getBorrowBalanceCurrent(address token, address user) external returns (uint256) {\n        address vTokenAddress = getVTokenForUnderlying(token);\n        return VTokenInterface(vTokenAddress).borrowBalanceCurrent(user);\n    }\n    \n    function getBorrowRate(address token) external view returns (uint256, bool) {\n        address vTokenAddress = getVTokenForUnderlying(token);\n        uint borrowRate = VTokenInterface(vTokenAddress).borrowRatePerBlock();\n        return (borrowRate, true);\n    }\n    \n    function getSupplyRate(address token) external view returns (uint256, bool) {\n        address vTokenAddress = getVTokenForUnderlying(token);\n        uint supplyRate = VTokenInterface(vTokenAddress).supplyRatePerBlock();\n        return (supplyRate, true);\n    }\n    \n    function getAllVenusMarkets() external view returns (\n        address[] memory vTokens,\n        address[] memory tokens,\n        string[] memory symbols,\n        string[] memory names,\n        uint8[] memory decimals,\n        uint256[] memory prices\n    ) {\n        // Get all markets from the comptroller\n        vTokens = this.getAllMarkets();\n        uint256 marketsCount = vTokens.length;\n        \n        // Initialize arrays\n        tokens = new address[](marketsCount);\n        symbols = new string[](marketsCount);\n        names = new string[](marketsCount);\n        decimals = new uint8[](marketsCount);\n        prices = new uint256[](marketsCount);\n        \n        // Populate arrays with basic token information\n        for (uint i = 0; i < marketsCount; i++) {\n            address vTokenAddress = vTokens[i];\n            VTokenInterface vToken = VTokenInterface(vTokenAddress);\n            \n            // Get underlying token address directly\n            try vToken.underlying() returns (address underlyingToken) {\n                tokens[i] = underlyingToken;\n                \n                // Get token metadata\n                IERC20Metadata underlying = IERC20Metadata(underlyingToken);\n                \n                // Try to get symbol from underlying, fallback to vToken\n                try underlying.symbol() returns (string memory s) {\n                    symbols[i] = s;\n                } catch {\n                    symbols[i] = vToken.symbol();\n                }\n                \n                // Try to get name from underlying, fallback to vToken\n                try underlying.name() returns (string memory n) {\n                    names[i] = n;\n                } catch {\n                    names[i] = vToken.name();\n                }\n                \n                // Try to get decimals from underlying, fallback to vToken\n                try underlying.decimals() returns (uint8 d) {\n                    decimals[i] = d;\n                } catch {\n                    decimals[i] = vToken.decimals();\n                }\n            } catch {\n                // For tokens like vBNB that might not have an underlying() function\n                tokens[i] = address(0);\n                symbols[i] = vToken.symbol();\n                names[i] = vToken.name();\n                decimals[i] = vToken.decimals();\n            }\n            prices[i] = oracle.getUnderlyingPrice(vTokenAddress);\n        }\n        \n        return (vTokens, tokens, symbols, names, decimals, prices);\n    }\n    \n    function getMarketRates(address[] calldata vTokens) external view returns (\n        uint256[] memory prices,\n        uint256[] memory supplyRates,\n        uint256[] memory borrowRates\n    ) {\n        uint256 marketsCount = vTokens.length;\n        \n        // Initialize arrays\n        prices = new uint256[](marketsCount);\n        supplyRates = new uint256[](marketsCount);\n        borrowRates = new uint256[](marketsCount);\n        \n        // Populate arrays with rate information\n        for (uint i = 0; i < marketsCount; i++) {\n            address vTokenAddress = vTokens[i];\n            VTokenInterface vToken = VTokenInterface(vTokenAddress);\n            \n            // Get rates\n            supplyRates[i] = vToken.supplyRatePerBlock();\n            borrowRates[i] = vToken.borrowRatePerBlock();\n            prices[i] = oracle.getUnderlyingPrice(vTokenAddress);\n        }\n        \n        return (prices, supplyRates, borrowRates);\n    }\n    \n    function getUserBalances(address[] calldata vTokens, address account) external view returns (\n        uint256[] memory balances,\n        uint256[] memory borrowBalances\n    ) {\n        require(account != address(0), \"VenusGateway: zero address not allowed\");\n        \n        uint256 marketsCount = vTokens.length;\n        \n        // Initialize arrays\n        balances = new uint256[](marketsCount);\n        borrowBalances = new uint256[](marketsCount);\n        \n        // Populate arrays with user balance information\n        for (uint i = 0; i < marketsCount; i++) {\n            address vTokenAddress = vTokens[i];\n            VTokenInterface vToken = VTokenInterface(vTokenAddress);\n            \n            // Get user balances\n            try vToken.balanceOf(account) returns (uint256 b) {\n                // Convert vToken balance to underlying using exchange rate\n                uint256 exchangeRate = vToken.exchangeRateStored();\n                balances[i] = (b * exchangeRate) / 1e18;\n            } catch {\n                balances[i] = 0;\n            }\n            \n            try vToken.borrowBalanceStored(account) returns (uint256 bb) {\n                borrowBalances[i] = bb;\n            } catch {\n                borrowBalances[i] = 0;\n            }\n        }\n        \n        return (balances, borrowBalances);\n    }\n    \n    function getCollateralStatus(address[] calldata vTokens, address account) external view returns (\n        bool[] memory isCollateral\n    ) {\n        require(account != address(0), \"VenusGateway: zero address not allowed\");\n        \n        uint256 marketsCount = vTokens.length;\n        isCollateral = new bool[](marketsCount);\n        \n        // Get the list of markets the user has entered (used as collateral)\n        address[] memory enteredMarkets = this.getAssetsIn(account);\n        \n        // Check each market if it's being used as collateral\n        for (uint i = 0; i < marketsCount; i++) {\n            address vTokenAddress = vTokens[i];\n            \n            // Linear search through entered markets\n            for (uint j = 0; j < enteredMarkets.length; j++) {\n                if (enteredMarkets[j] == vTokenAddress) {\n                    isCollateral[i] = true;\n                    break;\n                }\n            }\n        }\n        \n        return isCollateral;\n    }\n    \n    function getPossibleCollaterals(address token, address user) external view returns (\n        address[] memory collateralAddresses,\n        uint256[] memory balances,\n        string[] memory symbols,\n        uint8[] memory decimals\n    ) {\n        // Get all Venus markets information\n        (\n            address[] memory vTokens, \n            address[] memory tokens, \n            string[] memory tokenSymbols, \n            string[] memory names, \n            uint8[] memory tokenDecimals,\n            uint256[] memory prices\n        ) = this.getAllVenusMarkets();\n        \n        // Create arrays for return values\n        collateralAddresses = new address[](tokens.length);\n        symbols = new string[](tokens.length);\n        decimals = new uint8[](tokens.length);\n        balances = new uint256[](tokens.length); // Initialize with all zeros by default\n        \n        // If user address is provided and not zero, get their balances\n        if (user != address(0)) {\n            // Get user balances for all markets\n            (uint256[] memory userBalances, ) = this.getUserBalances(vTokens, user);\n            balances = userBalances;\n        }\n        \n        // Copy token information to return arrays\n        for (uint i = 0; i < tokens.length; i++) {\n            collateralAddresses[i] = tokens[i];\n            symbols[i] = tokenSymbols[i];\n            decimals[i] = tokenDecimals[i];\n        }\n        \n        return (collateralAddresses, balances, symbols, decimals);\n    }\n    \n    function isCollateralSupported(address market, address collateral) external view returns (bool isSupported) {\n        // Get all Venus markets information\n        (\n            ,  // vTokens (not needed)\n            address[] memory tokens, \n            , // symbols (not needed)\n            , // names (not needed)\n            , // decimals (not needed)\n              // prices (not needed)\n        ) = this.getAllVenusMarkets();\n        \n        // First check that both market and collateral are valid tokens in Venus\n        bool marketFound = false;\n        bool collateralFound = false;\n        \n        for (uint i = 0; i < tokens.length; i++) {\n            if (tokens[i] == market) {\n                marketFound = true;\n            }\n            if (tokens[i] == collateral) {\n                collateralFound = true;\n            }\n            \n            // Early exit if both are found\n            if (marketFound && collateralFound) {\n                break;\n            }\n        }\n        \n        // In Venus, any valid token can be collateral for any other valid token\n        return marketFound && collateralFound;\n    }\n    \n    function getSupportedCollaterals(address market) external view returns (address[] memory collateralAddresses) {\n        // Get all Venus markets information\n        (\n            ,  // vTokens (not needed)\n            address[] memory tokens, \n            ,  // symbols (not needed)\n            ,  // names (not needed)\n            ,// decimals (not needed)\n            // prices (not needed)\n        ) = this.getAllVenusMarkets();\n        \n        // Check if market is a valid token in Venus\n        bool marketFound = false;\n        for (uint i = 0; i < tokens.length; i++) {\n            if (tokens[i] == market) {\n                marketFound = true;\n                break;\n            }\n        }\n        \n        // If market is not found, return empty array\n        if (!marketFound) {\n            return new address[](0);\n        }\n        \n        // In Venus, all tokens can be collateral for any other token\n        // So we return all tokens except the market itself\n        collateralAddresses = new address[](tokens.length - 1);\n        \n        uint index = 0;\n        for (uint i = 0; i < tokens.length; i++) {\n            // Skip the market token itself\n            if (tokens[i] != market) {\n                collateralAddresses[index] = tokens[i];\n                index++;\n            }\n        }\n        \n        return collateralAddresses;\n    }\n    \n    function _weightedCollateralFactorBps(address user) internal view returns (uint256) {\n        // Ensure comptroller has code\n        if (address(comptroller).code.length == 0) return 0;\n        \n        // Get assets directly from comptroller\n        VTokenInterface[] memory vTokens;\n        try comptroller.getAssetsIn(user) returns (VTokenInterface[] memory v) {\n            vTokens = v;\n        } catch {\n            return 0;\n        }\n        \n        if (vTokens.length == 0) return 0;\n        \n        uint256 totalCollateralValue;\n        uint256 totalAllowedBorrow;\n\n        for (uint i = 0; i < vTokens.length; i++) {\n            address vTokenAddr = address(vTokens[i]);\n            \n            uint256 vBalance;\n            try vTokens[i].balanceOf(user) returns (uint256 b) { vBalance = b; } catch { continue; }\n            if (vBalance == 0) continue;\n\n            uint256 exchangeRate;\n            try vTokens[i].exchangeRateStored() returns (uint256 rate) { exchangeRate = rate; } catch { continue; }\n\n            uint256 underlyingAmount = (vBalance * exchangeRate) / 1e18;\n            \n            uint256 price;\n            try oracle.getUnderlyingPrice(vTokenAddr) returns (uint256 p) { price = p; } catch { continue; }\n            \n            uint256 collateralValue = (underlyingAmount * price) / 1e18;\n            totalCollateralValue += collateralValue;\n\n            // Venus v4: markets returns (isListed, collateralFactorMantissa, liquidationThresholdMantissa)\n            try comptroller.markets(vTokenAddr) returns (\n                bool /* isListed */,\n                uint256 collateralFactorMantissa,\n                uint256 /* liquidationThresholdMantissa */\n            ) {\n                totalAllowedBorrow += (collateralValue * collateralFactorMantissa) / 1e18;\n            } catch {\n                continue;\n            }\n        }\n\n        if (totalCollateralValue == 0) return 0;\n\n        return (totalAllowedBorrow * 10_000) / totalCollateralValue;\n    }\n\n    /// @notice Calculate weighted liquidation threshold (LLTV) across user's collateral positions\n    /// @dev Uses Venus V4's liquidationThreshold which is higher than collateralFactor\n    function _weightedLiquidationThresholdBps(address user) internal view returns (uint256) {\n        // Ensure comptroller has code\n        if (address(comptroller).code.length == 0) return 0;\n        \n        // Get assets directly from comptroller\n        VTokenInterface[] memory vTokens;\n        try comptroller.getAssetsIn(user) returns (VTokenInterface[] memory v) {\n            vTokens = v;\n        } catch {\n            return 0;\n        }\n        \n        if (vTokens.length == 0) return 0;\n        \n        uint256 totalCollateralValue;\n        uint256 totalLiquidationThreshold;\n\n        for (uint i = 0; i < vTokens.length; i++) {\n            address vTokenAddr = address(vTokens[i]);\n\n            uint256 vBalance;\n            try vTokens[i].balanceOf(user) returns (uint256 b) { vBalance = b; } catch { continue; }\n            if (vBalance == 0) continue;\n\n            uint256 exchangeRate;\n            try vTokens[i].exchangeRateStored() returns (uint256 rate) { exchangeRate = rate; } catch { continue; }\n\n            uint256 underlyingAmount = (vBalance * exchangeRate) / 1e18;\n            \n            uint256 price;\n            try oracle.getUnderlyingPrice(vTokenAddr) returns (uint256 p) { price = p; } catch { continue; }\n            \n            uint256 collateralValue = (underlyingAmount * price) / 1e18;\n            totalCollateralValue += collateralValue;\n\n            // Venus v4: markets returns (isListed, collateralFactorMantissa, liquidationThresholdMantissa)\n            // Use liquidationThresholdMantissa when available, otherwise fall back to collateralFactorMantissa.\n            try comptroller.markets(vTokenAddr) returns (\n                bool /* isListed */,\n                uint256 collateralFactorMantissa,\n                uint256 liquidationThresholdMantissa\n            ) {\n                uint256 liqThreshold = liquidationThresholdMantissa == 0\n                    ? collateralFactorMantissa\n                    : liquidationThresholdMantissa;\n\n                totalLiquidationThreshold += (collateralValue * liqThreshold) / 1e18;\n            } catch {\n                continue;\n            }\n        }\n\n        if (totalCollateralValue == 0) return 0;\n\n        return (totalLiquidationThreshold * 10_000) / totalCollateralValue;\n    }\n\n    /// @notice Returns the LTV (borrowing power) for a user in basis points\n    /// @dev Uses collateralFactor which determines how much can be borrowed\n    function getLtv(address /* token */, address user) external view returns (uint256 result) {\n        if (user == address(0)) return 0;\n        return _weightedCollateralFactorBps(user);\n    }\n\n    /// @notice Returns the LLTV (liquidation threshold) for a user in basis points\n    /// @dev Uses liquidationThreshold which is higher than LTV - the point at which liquidation occurs\n    function getMaxLtv(address /* token */, address user) external view returns (uint256 result) {\n        if (user == address(0)) return 0;\n        return _weightedLiquidationThresholdBps(user);\n    }\n\n    /// @notice Returns the current LTV (debt/collateral) in basis points\n    /// @dev This is the actual current LTV = totalDebt / totalCollateral * 10000\n    /// @param user The user address\n    /// @return Current LTV in basis points (e.g., 6500 = 65%)\n    function getCurrentLtvBps(address /* token */, address user) external view returns (uint256) {\n        if (user == address(0)) return 0;\n\n        VTokenInterface[] memory vTokens = comptroller.getAssetsIn(user);\n        if (vTokens.length == 0) return 0;\n\n        uint256 totalCollateralValue;\n        uint256 totalDebtValue;\n\n        for (uint i = 0; i < vTokens.length; i++) {\n            address vTokenAddr = address(vTokens[i]);\n            VTokenInterface vToken = VTokenInterface(vTokenAddr);\n\n            // Get oracle price (18 decimals, price per underlying token)\n            uint256 price;\n            try oracle.getUnderlyingPrice(vTokenAddr) returns (uint256 p) { price = p; } catch { continue; }\n\n            // Calculate collateral value\n            uint256 vTokenBalance = vToken.balanceOf(user);\n            if (vTokenBalance > 0) {\n                uint256 exchangeRate = vToken.exchangeRateStored();\n                uint256 underlyingAmount = (vTokenBalance * exchangeRate) / 1e18;\n                totalCollateralValue += (underlyingAmount * price) / 1e18;\n            }\n\n            // Calculate debt value\n            try vToken.borrowBalanceStored(user) returns (uint256 borrowBalance) {\n                if (borrowBalance > 0) {\n                    totalDebtValue += (borrowBalance * price) / 1e18;\n                }\n            } catch {}\n        }\n\n        if (totalCollateralValue == 0) return 0;\n        return (totalDebtValue * 10_000) / totalCollateralValue;\n    }\n\n    /// @notice Returns the liquidation LTV threshold in basis points\n    /// @dev Position is liquidatable when currentLTV >= liquidationLtvBps\n    /// @param user The user address\n    /// @return Weighted liquidation threshold in basis points\n    function getLiquidationLtvBps(address /* token */, address user) external view returns (uint256) {\n        if (user == address(0)) return 0;\n        return _weightedLiquidationThresholdBps(user);\n    }\n\n    /// @notice Reserve configuration for LTV calculations (matches Aave/Compound pattern)\n    struct ReserveConfigData {\n        address token;\n        address vToken;\n        uint256 price;              // Price from oracle (18 decimals)\n        uint256 ltv;                // Collateral factor in basis points (0-10000)\n        uint256 liquidationThreshold; // Liquidation threshold in basis points\n        uint8 decimals;\n        bool isListed;\n    }\n\n    /// @notice Get reserve configuration data for all Venus markets (for frontend LTV calculations)\n    /// @dev Returns price, LTV (collateral factor), liquidation threshold for each market\n    /// @return configs Array of reserve configuration data\n    function getReserveConfigs() external view returns (ReserveConfigData[] memory configs) {\n        VTokenInterface[] memory vTokens = comptroller.getAllMarkets();\n        configs = new ReserveConfigData[](vTokens.length);\n\n        for (uint i = 0; i < vTokens.length; i++) {\n            address vTokenAddr = address(vTokens[i]);\n            VTokenInterface vToken = vTokens[i];\n\n            // Get underlying token\n            address underlying;\n            try vToken.underlying() returns (address u) {\n                underlying = u;\n            } catch {\n                underlying = address(0); // e.g., vBNB\n            }\n\n            // Get decimals\n            uint8 dec = 18;\n            if (underlying != address(0)) {\n                try IERC20Metadata(underlying).decimals() returns (uint8 d) {\n                    dec = d;\n                } catch {}\n            }\n\n            // Get price\n            uint256 price = 0;\n            try oracle.getUnderlyingPrice(vTokenAddr) returns (uint256 p) {\n                price = p;\n            } catch {}\n\n            // Get market config (isListed, collateralFactorMantissa, liquidationThresholdMantissa)\n            bool isListed = false;\n            uint256 ltvBps = 0;\n            uint256 liqThresholdBps = 0;\n\n            try comptroller.markets(vTokenAddr) returns (\n                bool _isListed,\n                uint256 collateralFactorMantissa,\n                uint256 liquidationThresholdMantissa\n            ) {\n                isListed = _isListed;\n                // Convert from 1e18 scale to basis points (10000 = 100%)\n                ltvBps = (collateralFactorMantissa * 10_000) / 1e18;\n                // Use liquidationThreshold if available, otherwise use collateralFactor\n                uint256 liqThreshold = liquidationThresholdMantissa == 0 \n                    ? collateralFactorMantissa \n                    : liquidationThresholdMantissa;\n                liqThresholdBps = (liqThreshold * 10_000) / 1e18;\n            } catch {}\n\n            configs[i] = ReserveConfigData({\n                token: underlying,\n                vToken: vTokenAddr,\n                price: price,\n                ltv: ltvBps,\n                liquidationThreshold: liqThresholdBps,\n                decimals: dec,\n                isListed: isListed\n            });\n        }\n    }\n\n    /// @notice Get collateral factors for all markets (similar to Compound's getCollateralFactors)\n    /// @return assets Array of underlying token addresses\n    /// @return ltvBps Array of LTV values in basis points\n    /// @return lltvBps Array of liquidation threshold values in basis points\n    function getCollateralFactors() external view returns (\n        address[] memory assets,\n        uint256[] memory ltvBps,\n        uint256[] memory lltvBps\n    ) {\n        VTokenInterface[] memory vTokens = comptroller.getAllMarkets();\n        uint256 numMarkets = vTokens.length;\n\n        assets = new address[](numMarkets);\n        ltvBps = new uint256[](numMarkets);\n        lltvBps = new uint256[](numMarkets);\n\n        for (uint i = 0; i < numMarkets; i++) {\n            address vTokenAddr = address(vTokens[i]);\n\n            // Get underlying token\n            try vTokens[i].underlying() returns (address u) {\n                assets[i] = u;\n            } catch {\n                assets[i] = address(0);\n            }\n\n            // Get market config\n            try comptroller.markets(vTokenAddr) returns (\n                bool /* isListed */,\n                uint256 collateralFactorMantissa,\n                uint256 liquidationThresholdMantissa\n            ) {\n                ltvBps[i] = (collateralFactorMantissa * 10_000) / 1e18;\n                uint256 liqThreshold = liquidationThresholdMantissa == 0 \n                    ? collateralFactorMantissa \n                    : liquidationThresholdMantissa;\n                lltvBps[i] = (liqThreshold * 10_000) / 1e18;\n            } catch {}\n        }\n    }\n\n    // ============ Price Queries (for ADL) ============\n\n    /// @notice Get user account data for ADL trigger calculation\n    /// @dev Returns collateral and debt values in 8-decimal USD\n    /// @param user The user address\n    /// @return totalCollateralUsd Total collateral value in 8-decimal USD\n    /// @return totalDebtUsd Total debt value in 8-decimal USD\n    function getUserAccountData(address user)\n        external\n        view\n        returns (uint256 totalCollateralUsd, uint256 totalDebtUsd)\n    {\n        if (user == address(0)) return (0, 0);\n\n        VTokenInterface[] memory vTokens = comptroller.getAssetsIn(user);\n        if (vTokens.length == 0) return (0, 0);\n\n        uint256 totalCollateral18;\n        uint256 totalDebt18;\n\n        for (uint i = 0; i < vTokens.length; i++) {\n            address vTokenAddr = address(vTokens[i]);\n            VTokenInterface vToken = VTokenInterface(vTokenAddr);\n\n            uint256 price;\n            try oracle.getUnderlyingPrice(vTokenAddr) returns (uint256 p) { price = p; } catch { continue; }\n\n            // Collateral value\n            uint256 vTokenBalance = vToken.balanceOf(user);\n            if (vTokenBalance > 0) {\n                uint256 exchangeRate = vToken.exchangeRateStored();\n                uint256 underlyingAmount = (vTokenBalance * exchangeRate) / 1e18;\n                totalCollateral18 += (underlyingAmount * price) / 1e18;\n            }\n\n            // Debt value\n            try vToken.borrowBalanceStored(user) returns (uint256 borrowBalance) {\n                if (borrowBalance > 0) {\n                    totalDebt18 += (borrowBalance * price) / 1e18;\n                }\n            } catch {}\n        }\n\n        // Convert from 18 decimals to 8 decimals\n        totalCollateralUsd = totalCollateral18 / 1e10;\n        totalDebtUsd = totalDebt18 / 1e10;\n    }\n\n    /// @notice Get the price of an underlying asset in Venus oracle format\n    /// @dev Venus oracle returns price as: price_usd * 10^(36 - tokenDecimals)\n    ///      For WETH (18 dec): price * 1e18. For USDC (6 dec): price * 1e30.\n    /// @param underlyingToken The underlying asset address\n    /// @return price Price in Venus oracle format (36 - tokenDecimals decimals)\n    function getAssetPrice(address underlyingToken) external view returns (uint256 price) {\n        address vTokenAddress = getVTokenForUnderlying(underlyingToken);\n        if (vTokenAddress == address(0)) return 0;\n        try oracle.getUnderlyingPrice(vTokenAddress) returns (uint256 p) {\n            return p;\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice Get the price of an underlying asset normalized to 8 decimals\n    /// @dev Venus oracle returns price as price_usd * 10^(36 - tokenDecimals).\n    ///      To normalize to 8 decimals: divide by 10^(28 - tokenDecimals).\n    /// @param underlyingToken The underlying asset address\n    /// @return price Price in 8 decimals (for consistency with other protocols)\n    function getAssetPrice8(address underlyingToken) external view returns (uint256 price) {\n        address vTokenAddress = getVTokenForUnderlying(underlyingToken);\n        if (vTokenAddress == address(0)) return 0;\n        try oracle.getUnderlyingPrice(vTokenAddress) returns (uint256 p) {\n            // Venus oracle: price_usd * 10^(36 - tokenDecimals)\n            // Target:       price_usd * 10^8\n            // Divisor:      10^(28 - tokenDecimals)\n            uint8 tokenDecimals = 18;\n            try IERC20Metadata(underlyingToken).decimals() returns (uint8 d) {\n                tokenDecimals = d;\n            } catch {}\n            if (tokenDecimals < 28) {\n                return p / (10 ** (28 - uint256(tokenDecimals)));\n            } else {\n                return p * (10 ** (uint256(tokenDecimals) - 28));\n            }\n        } catch {\n            return 0;\n        }\n    }\n}\n\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}