{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/v2/cow/KapanConditionalOrderHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { IConditionalOrder, IConditionalOrderGenerator, PollTryNextBlock, PollNever, OrderNotValid } from \"../interfaces/cow/IConditionalOrder.sol\";\nimport { GPv2Order } from \"../interfaces/cow/GPv2Order.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IOrderTrigger } from \"../interfaces/IOrderTrigger.sol\";\n\n/// @notice Minimal interface to read from KapanConditionalOrderManager\ninterface IKapanConditionalOrderManager {\n    enum OrderStatus { None, Active, Completed, Cancelled }\n\n    struct KapanOrderParams {\n        address user;\n        address trigger;\n        bytes triggerStaticData;\n        bytes preInstructions;\n        address sellToken;\n        address buyToken;\n        bytes postInstructions;\n        bytes32 appDataHash;\n        uint256 maxIterations;\n        address sellTokenRefundAddress;\n    }\n\n    struct OrderContext {\n        KapanOrderParams params;\n        OrderStatus status;\n        uint256 iterationCount;\n        uint256 createdAt;\n    }\n\n    function getOrder(bytes32 orderHash) external view returns (OrderContext memory);\n    function chunkWindow() external view returns (uint256);\n}\n\n/// @title KapanConditionalOrderHandler\n/// @notice Generates CoW Protocol orders for Kapan conditional/trigger-based orders (ADL, stop-loss, etc.)\n/// @dev Implements IConditionalOrderGenerator for ComposableCoW integration.\n///      This is a STATELESS handler that reads order data from KapanConditionalOrderManager.\n///      Separating handler from manager is required because:\n///      - Handler must implement IERC165 for ComposableCoW to verify interface support\n///      - Manager (owner) must NOT implement IERC165 to avoid Safe/fallback handler path\ncontract KapanConditionalOrderHandler is IConditionalOrderGenerator, IERC165 {\n\n    // ============ State Variables ============\n\n    /// @notice The KapanConditionalOrderManager that stores order contexts\n    IKapanConditionalOrderManager public immutable manager;\n\n    // ============ Constructor ============\n\n    constructor(address _manager) {\n        require(_manager != address(0), \"Invalid manager\");\n        manager = IKapanConditionalOrderManager(_manager);\n    }\n\n    // ============ IConditionalOrderGenerator Implementation ============\n\n    /// @notice Generate a tradeable order if trigger condition is met\n    /// @dev Called by ComposableCoW via getTradeableOrderWithSignature\n    /// @param staticInput ABI-encoded orderHash\n    /// @return order The GPv2Order.Data struct\n    function getTradeableOrder(\n        address,\n        address,\n        bytes32,\n        bytes calldata staticInput,\n        bytes calldata\n    ) external view override returns (GPv2Order.Data memory order) {\n        bytes32 orderHash = abi.decode(staticInput, (bytes32));\n        IKapanConditionalOrderManager.OrderContext memory ctx = manager.getOrder(orderHash);\n\n        // Validate order is active\n        if (ctx.status != IKapanConditionalOrderManager.OrderStatus.Active) {\n            revert PollNever(\"order_not_active\");\n        }\n\n        // Get trigger\n        IOrderTrigger trigger = IOrderTrigger(ctx.params.trigger);\n\n        // Check if order is complete\n        if (trigger.isComplete(ctx.params.triggerStaticData, ctx.params.user, ctx.iterationCount)) {\n            revert PollNever(\"trigger_complete\");\n        }\n        if (ctx.params.maxIterations > 0 && ctx.iterationCount >= ctx.params.maxIterations) {\n            revert PollNever(\"max_iterations_reached\");\n        }\n\n        // Check trigger condition\n        (bool shouldExecute, string memory reason) = trigger.shouldExecute(\n            ctx.params.triggerStaticData,\n            ctx.params.user\n        );\n\n        if (!shouldExecute) {\n            revert PollTryNextBlock(reason);\n        }\n\n        // Calculate amounts from trigger (trigger handles precision truncation to prevent spam)\n        (uint256 sellAmount, uint256 minBuyAmount) = trigger.calculateExecution(\n            ctx.params.triggerStaticData,\n            ctx.params.user\n        );\n\n        if (sellAmount == 0) {\n            revert PollNever(\"zero_sell_amount\");\n        }\n\n        // Calculate deterministic validTo\n        uint256 validTo = _calculateValidTo(ctx.createdAt, ctx.iterationCount);\n\n        // Verify order hasn't expired\n        if (block.timestamp > validTo) {\n            revert PollTryNextBlock(\"window_expired\");\n        }\n\n        // Build the order - receiver is manager (for post-hook token handling)\n        order = GPv2Order.Data({\n            sellToken: IERC20(ctx.params.sellToken),\n            buyToken: IERC20(ctx.params.buyToken),\n            receiver: address(manager),\n            sellAmount: sellAmount,\n            buyAmount: minBuyAmount,\n            validTo: uint32(validTo),\n            appData: ctx.params.appDataHash,\n            feeAmount: 0,\n            kind: GPv2Order.KIND_SELL,\n            partiallyFillable: false,\n            sellTokenBalance: GPv2Order.BALANCE_ERC20,\n            buyTokenBalance: GPv2Order.BALANCE_ERC20\n        });\n    }\n\n    /// @notice Verify that a proposed order matches the conditional order\n    /// @dev Called by ComposableCoW during signature verification\n    function verify(\n        address,\n        address,\n        bytes32,\n        bytes32,\n        bytes32,\n        bytes calldata staticInput,\n        bytes calldata,\n        GPv2Order.Data calldata order\n    ) external view override {\n        bytes32 orderHash = abi.decode(staticInput, (bytes32));\n        IKapanConditionalOrderManager.OrderContext memory ctx = manager.getOrder(orderHash);\n\n        if (ctx.status != IKapanConditionalOrderManager.OrderStatus.Active) {\n            revert OrderNotValid(\"order_not_active\");\n        }\n\n        // Validate tokens match\n        if (address(order.sellToken) != ctx.params.sellToken) {\n            revert OrderNotValid(\"sell_token_mismatch\");\n        }\n        if (address(order.buyToken) != ctx.params.buyToken) {\n            revert OrderNotValid(\"buy_token_mismatch\");\n        }\n\n        // Validate receiver is manager\n        if (order.receiver != address(manager)) {\n            revert OrderNotValid(\"invalid_receiver\");\n        }\n\n        // Validate appData\n        if (order.appData != ctx.params.appDataHash) {\n            revert OrderNotValid(\"appdata_mismatch\");\n        }\n    }\n\n    // ============ Internal Functions ============\n\n    /// @notice Calculate deterministic validTo timestamp\n    /// @dev Reads chunkWindow from manager for consistency\n    function _calculateValidTo(uint256 createdAt, uint256 iterationCount) internal view returns (uint256) {\n        uint256 window = manager.chunkWindow();\n        uint256 chunkWindowStart = createdAt + (iterationCount * window);\n        uint256 chunkWindowEnd = chunkWindowStart + window - 1;\n\n        if (block.timestamp <= chunkWindowEnd) {\n            return chunkWindowEnd;\n        }\n\n        // Extend to current window\n        uint256 elapsedSinceCreate = block.timestamp - createdAt;\n        uint256 currentWindowIndex = elapsedSinceCreate / window;\n        return createdAt + ((currentWindowIndex + 1) * window) - 1;\n    }\n\n    // ============ ERC-165 Implementation ============\n\n    /// @notice Check if contract supports an interface\n    /// @dev Required for ComposableCoW to verify handler compatibility\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(IConditionalOrderGenerator).interfaceId ||\n               interfaceId == type(IConditionalOrder).interfaceId ||\n               interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/v2/interfaces/cow/GPv2Order.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title GPv2Order - CoW Protocol order library\n/// @notice Data structures and helpers for CoW Protocol orders\nlibrary GPv2Order {\n    /// @dev The complete order data that is signed by the user\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev Order kind constants\n    bytes32 internal constant KIND_SELL =\n        keccak256(\"sell\");\n    bytes32 internal constant KIND_BUY =\n        keccak256(\"buy\");\n\n    /// @dev Token balance constants\n    bytes32 internal constant BALANCE_ERC20 =\n        keccak256(\"erc20\");\n    bytes32 internal constant BALANCE_EXTERNAL =\n        keccak256(\"external\");\n    bytes32 internal constant BALANCE_INTERNAL =\n        keccak256(\"internal\");\n\n    /// @dev The order EIP-712 type hash\n    bytes32 internal constant TYPE_HASH =\n        keccak256(\n            \"Order(\"\n            \"address sellToken,\"\n            \"address buyToken,\"\n            \"address receiver,\"\n            \"uint256 sellAmount,\"\n            \"uint256 buyAmount,\"\n            \"uint32 validTo,\"\n            \"bytes32 appData,\"\n            \"uint256 feeAmount,\"\n            \"string kind,\"\n            \"bool partiallyFillable,\"\n            \"string sellTokenBalance,\"\n            \"string buyTokenBalance\"\n            \")\"\n        );\n\n    /// @dev Computes the order hash for the given order data\n    /// @param order The order to hash\n    /// @param domainSeparator The EIP-712 domain separator\n    /// @return orderDigest The order digest\n    function hash(Data memory order, bytes32 domainSeparator) internal pure returns (bytes32 orderDigest) {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                TYPE_HASH,\n                order.sellToken,\n                order.buyToken,\n                order.receiver,\n                order.sellAmount,\n                order.buyAmount,\n                order.validTo,\n                order.appData,\n                order.feeAmount,\n                order.kind,\n                order.partiallyFillable,\n                order.sellTokenBalance,\n                order.buyTokenBalance\n            )\n        );\n        orderDigest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/v2/interfaces/cow/IConditionalOrder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { GPv2Order } from \"./GPv2Order.sol\";\n\n/// @title IConditionalOrder - Interface for conditional order handlers\n/// @notice Defines the interface for creating conditional/programmatic orders on CoW Protocol\ninterface IConditionalOrder {\n    /// @dev Conditional order parameters stored on-chain\n    struct ConditionalOrderParams {\n        IConditionalOrder handler;\n        bytes32 salt;\n        bytes staticData;\n    }\n\n    /// @notice Verifies that a discrete order is valid for the conditional order\n    /// @param owner The owner of the conditional order\n    /// @param sender The msg.sender calling isValidSignature\n    /// @param _hash The EIP-712 order digest\n    /// @param domainSeparator The EIP-712 domain separator\n    /// @param ctx The execution context (H(params) for single, merkle root for tree)\n    /// @param staticInput Order-specific data known at creation time\n    /// @param offchainInput Order-specific data NOT known at creation time\n    /// @param order The proposed discrete order\n    function verify(\n        address owner,\n        address sender,\n        bytes32 _hash,\n        bytes32 domainSeparator,\n        bytes32 ctx,\n        bytes calldata staticInput,\n        bytes calldata offchainInput,\n        GPv2Order.Data calldata order\n    ) external view;\n}\n\n/// @title IConditionalOrderGenerator - Interface for conditional order generators\n/// @notice Extends IConditionalOrder to generate tradeable orders\ninterface IConditionalOrderGenerator is IConditionalOrder {\n    /// @notice Generates a tradeable GPv2Order based on the current state\n    /// @param owner The owner of the conditional order\n    /// @param sender The msg.sender (usually ComposableCoW)\n    /// @param ctx The execution context\n    /// @param staticInput Order-specific data known at creation time\n    /// @param offchainInput Order-specific data provided by the watch-tower\n    /// @return order The generated GPv2Order.Data struct\n    function getTradeableOrder(\n        address owner,\n        address sender,\n        bytes32 ctx,\n        bytes calldata staticInput,\n        bytes calldata offchainInput\n    ) external view returns (GPv2Order.Data memory order);\n}\n\n/// @title Conditional Order Errors\n/// @notice Custom errors for signaling to watch-towers\n\n/// @dev Signal to try polling again at the next block\nerror PollTryNextBlock(string reason);\n\n/// @dev Signal to try polling at a specific block\nerror PollTryAtBlock(uint256 blockNumber, string reason);\n\n/// @dev Signal to try polling at a specific timestamp\nerror PollTryAtEpoch(uint256 timestamp, string reason);\n\n/// @dev Signal to stop polling this order (completed or cancelled)\nerror PollNever(string reason);\n\n/// @dev Signal that the order parameters are invalid\nerror OrderNotValid(string reason);\n\n/// @dev Signal that the order is not currently tradeable\nerror OrderNotReady(string reason);\n"
    },
    "contracts/v2/interfaces/IOrderTrigger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IOrderTrigger\n/// @notice Interface for pluggable order triggers in the Kapan conditional order system\n/// @dev Triggers determine when an order should execute and how much to trade\ninterface IOrderTrigger {\n    /// @notice Check if the order should execute based on current conditions\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner (user whose position is being monitored)\n    /// @return shouldExecute True if the trigger condition is met\n    /// @return reason Human-readable reason for the result (for debugging/logging)\n    function shouldExecute(\n        bytes calldata staticData,\n        address owner\n    ) external view returns (bool shouldExecute, string memory reason);\n\n    /// @notice Calculate the execution amounts when the trigger fires\n    /// @dev Only called when shouldExecute returns true\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner\n    /// @return sellAmount Amount of sell token to trade in this execution\n    /// @return minBuyAmount Minimum amount to receive (includes slippage protection)\n    function calculateExecution(\n        bytes calldata staticData,\n        address owner\n    ) external view returns (uint256 sellAmount, uint256 minBuyAmount);\n\n    /// @notice Check if the order is complete and should stop executing\n    /// @dev Called after each execution to determine if order should be marked complete\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner\n    /// @param iterationCount Number of executions completed so far\n    /// @return complete True if the order goal has been reached\n    function isComplete(\n        bytes calldata staticData,\n        address owner,\n        uint256 iterationCount\n    ) external view returns (bool complete);\n\n    /// @notice Get human-readable name of the trigger type\n    /// @return name Trigger name (e.g., \"LTV\", \"Price\", \"HealthFactor\")\n    function triggerName() external pure returns (string memory name);\n}\n"
    },
    "contracts/v2/triggers/AutoLeverageTrigger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { IOrderTrigger } from \"../interfaces/IOrderTrigger.sol\";\n\n/// @notice Morpho Blue MarketParams structure\nstruct MarketParams {\n    address loanToken;\n    address collateralToken;\n    address oracle;\n    address irm;\n    uint256 lltv;\n}\n\n/// @title KapanViewRouter Interface (same as LtvTrigger)\ninterface IKapanViewRouter {\n    function getCurrentLtv(bytes4 protocolId, address user, bytes calldata context) external view returns (uint256 ltvBps);\n    function getPositionValue(bytes4 protocolId, address user, bytes calldata context) external view returns (uint256 collateralValueUsd, uint256 debtValueUsd);\n    function getCollateralPrice(bytes4 protocolId, address collateralToken, bytes calldata context) external view returns (uint256 price);\n    function getDebtPrice(bytes4 protocolId, address debtToken, bytes calldata context) external view returns (uint256 price);\n    function getMorphoOraclePrice(MarketParams calldata params) external view returns (uint256 price);\n}\n\n/// @title AutoLeverageTrigger\n/// @notice Triggers order execution when position LTV drops BELOW a threshold (auto-leverage)\n/// @dev Opposite of LtvTrigger - increases leverage when under-leveraged\n///\n/// Flow:\n/// 1. Pre-hook: Flash loan collateral → Deposit → Borrow debt → Push to OrderManager\n/// 2. CoW Swap: Debt → Collateral\n/// 3. Post-hook: Repay flash loan with received collateral\n///\n/// Order params:\n///   - sellToken = debtToken (we're selling borrowed debt)\n///   - buyToken = collateralToken (we're buying collateral to repay flash loan)\ncontract AutoLeverageTrigger is IOrderTrigger {\n    // ============ Errors ============\n    error InvalidTriggerParams();\n\n    // ============ Constants ============\n    bytes4 public constant AAVE_V3 = bytes4(keccak256(\"aave-v3\"));\n    bytes4 public constant COMPOUND_V3 = bytes4(keccak256(\"compound-v3\"));\n    bytes4 public constant MORPHO_BLUE = bytes4(keccak256(\"morpho-blue\"));\n    bytes4 public constant EULER_V2 = bytes4(keccak256(\"euler-v2\"));\n\n    // ============ Immutables ============\n    IKapanViewRouter public immutable viewRouter;\n\n    // ============ Structs ============\n\n    /// @notice Trigger parameters for LTV-based auto-leverage\n    struct TriggerParams {\n        bytes4 protocolId;          // Protocol identifier\n        bytes protocolContext;       // Protocol-specific data\n        uint256 triggerLtvBps;       // LTV threshold BELOW which to trigger (e.g., 5000 = 50%)\n        uint256 targetLtvBps;        // Target LTV after leverage (e.g., 7000 = 70%)\n        address collateralToken;     // Token to BUY (receive from swap, repay flash loan)\n        address debtToken;           // Token to SELL (borrow and swap)\n        uint8 collateralDecimals;\n        uint8 debtDecimals;\n        uint256 maxSlippageBps;      // Maximum slippage tolerance\n        uint8 numChunks;             // Number of chunks (1 = full amount)\n    }\n\n    // ============ Constructor ============\n\n    constructor(address _viewRouter) {\n        if (_viewRouter == address(0)) revert InvalidTriggerParams();\n        viewRouter = IKapanViewRouter(_viewRouter);\n    }\n\n    // ============ IOrderTrigger Implementation ============\n\n    /// @inheritdoc IOrderTrigger\n    function shouldExecute(\n        bytes calldata staticData,\n        address owner\n    ) external view override returns (bool, string memory) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        uint256 currentLtv = viewRouter.getCurrentLtv(params.protocolId, owner, params.protocolContext);\n\n        if (currentLtv == 0) {\n            return (false, \"No position\");\n        }\n\n        // Trigger when UNDER-leveraged (LTV too low)\n        if (currentLtv < params.triggerLtvBps) {\n            return (true, \"LTV below threshold - under-leveraged\");\n        }\n\n        return (false, \"LTV above threshold\");\n    }\n\n    /// @inheritdoc IOrderTrigger\n    /// @dev Returns:\n    ///   - sellAmount: debt tokens to borrow and swap\n    ///   - minBuyAmount: collateral tokens expected (must cover flash loan + fee)\n    function calculateExecution(\n        bytes calldata staticData,\n        address owner\n    ) external view override returns (uint256 sellAmount, uint256 minBuyAmount) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        // Get current position value in USD (8 decimals)\n        (uint256 collateralValueUsd, uint256 debtValueUsd) = viewRouter.getPositionValue(\n            params.protocolId,\n            owner,\n            params.protocolContext\n        );\n\n        if (collateralValueUsd == 0) return (0, 0);\n\n        uint256 currentLtv = (debtValueUsd * 10000) / collateralValueUsd;\n        if (currentLtv >= params.targetLtvBps) return (0, 0); // Already at or above target\n\n        // Calculate how much additional debt (in USD) to reach target LTV\n        //\n        // After leverage:\n        //   newDebt / newCollateral = targetLTV\n        //   (D + ΔD) / (C + ΔC) = targetLTV\n        //\n        // Where ΔC ≈ ΔD (collateral received from swapping debt, roughly 1:1 in USD value)\n        //\n        // Solving for ΔD:\n        //   D + ΔD = targetLTV × (C + ΔD)\n        //   D + ΔD = targetLTV × C + targetLTV × ΔD\n        //   ΔD × (1 - targetLTV) = targetLTV × C - D\n        //   ΔD = (targetLTV × C - D) / (1 - targetLTV)\n        //\n        // This is the inverse of the ADL formula (which reduces both C and D)\n        uint256 targetDebtUsd = (params.targetLtvBps * collateralValueUsd) / 10000;\n        if (targetDebtUsd <= debtValueUsd) return (0, 0); // Already at or above target\n\n        uint256 numerator = targetDebtUsd - debtValueUsd;\n        uint256 denominator = 10000 - params.targetLtvBps;\n        if (denominator == 0) return (0, 0); // Prevent division by zero at 100% LTV\n\n        uint256 deltaDebtUsd = (numerator * 10000) / denominator;\n\n        // Convert USD to debt token amount\n        uint256 debtPrice = viewRouter.getDebtPrice(params.protocolId, params.debtToken, params.protocolContext);\n        sellAmount = (deltaDebtUsd * (10 ** params.debtDecimals)) / debtPrice;\n\n        // Apply chunking\n        uint8 chunks = params.numChunks > 0 ? params.numChunks : 1;\n        if (chunks > 1) {\n            sellAmount = sellAmount / chunks;\n        }\n\n        if (sellAmount == 0) return (0, 0);\n\n        // Truncate precision to prevent order spam from interest-bearing tokens\n        // Interest changes cause slightly different amounts each block → different order hash → spam\n        sellAmount = _truncatePrecision(sellAmount, params.debtDecimals);\n\n        if (sellAmount == 0) return (0, 0);\n\n        // Calculate minBuyAmount (collateral) with slippage\n        // This must cover the flash loan repayment\n        uint256 expectedCollateral;\n\n        if (params.protocolId == MORPHO_BLUE) {\n            // Morpho uses a special oracle that returns collateral/debt exchange rate at 36 decimals\n            // Formula: collateralAmount = debtAmount * 1e36 / oraclePrice\n            // The oracle accounts for decimal differences between tokens\n            MarketParams memory marketParams = abi.decode(params.protocolContext, (MarketParams));\n            uint256 morphoOraclePrice = viewRouter.getMorphoOraclePrice(marketParams);\n            if (morphoOraclePrice > 0) {\n                // sellAmount is in debt token decimals, result is in collateral token decimals\n                expectedCollateral = (sellAmount * 1e36) / morphoOraclePrice;\n            }\n        } else {\n            // Standard price-based calculation for other protocols\n            uint256 collateralPrice = viewRouter.getCollateralPrice(\n                params.protocolId,\n                params.collateralToken,\n                params.protocolContext\n            );\n\n            if (collateralPrice > 0) {\n                // Expected collateral = sellAmount(debt) × debtPrice / collateralPrice\n                expectedCollateral = (sellAmount * debtPrice) / collateralPrice;\n                // Adjust for decimals\n                expectedCollateral = (expectedCollateral * (10 ** params.collateralDecimals)) / (10 ** params.debtDecimals);\n            }\n        }\n\n        // Apply slippage\n        minBuyAmount = (expectedCollateral * (10000 - params.maxSlippageBps)) / 10000;\n\n        // Truncate minBuyAmount to prevent spam from price fluctuations\n        minBuyAmount = _truncatePrecision(minBuyAmount, params.collateralDecimals);\n    }\n\n    /// @inheritdoc IOrderTrigger\n    /// @dev Auto-leverage orders are continuous - they never auto-complete.\n    /// The order remains active and will re-trigger whenever LTV drops below\n    /// the trigger threshold, up to maxIterations or until user cancels.\n    /// This provides ongoing leverage management rather than one-shot execution.\n    function isComplete(\n        bytes calldata /* staticData */,\n        address /* owner */,\n        uint256 /* iterationCount */\n    ) external pure override returns (bool) {\n        // Never auto-complete - rely on maxIterations for termination\n        return false;\n    }\n\n    /// @inheritdoc IOrderTrigger\n    function triggerName() external pure override returns (string memory) {\n        return \"AutoLeverage\";\n    }\n\n    // ============ View Helpers ============\n\n    /// @notice Get current LTV for a user\n    function getCurrentLtv(bytes4 protocolId, address owner, bytes calldata context) external view returns (uint256) {\n        return viewRouter.getCurrentLtv(protocolId, owner, context);\n    }\n\n    /// @notice Encode trigger params for order creation\n    function encodeTriggerParams(TriggerParams memory params) external pure returns (bytes memory) {\n        return abi.encode(params);\n    }\n\n    // ============ Internal Functions ============\n\n    /// @dev Truncate precision to prevent order spam from interest-bearing tokens\n    /// Uses (amount / precision) * precision where precision = 10^(decimals - 3)\n    /// This keeps 3 decimal places, absorbing interest fluctuations between polls\n    function _truncatePrecision(uint256 amount, uint8 decimals) internal pure returns (uint256) {\n        if (amount == 0) return 0;\n\n        // Calculate precision: keep 3 decimal places (0.001 in token units)\n        uint256 precision = decimals > 3 ? 10 ** (decimals - 3) : 1;\n\n        return (amount / precision) * precision;\n    }\n\n}\n"
    },
    "contracts/v2/triggers/LtvTrigger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { IOrderTrigger } from \"../interfaces/IOrderTrigger.sol\";\n\n/// @title KapanViewRouter Interface\n/// @dev Minimal interface for LtvTrigger - uses unified functions with context\ninterface IKapanViewRouter {\n    /// @notice Get current LTV for any protocol\n    /// @param protocolId Protocol identifier (AAVE_V3, COMPOUND_V3, etc.)\n    /// @param user User address\n    /// @param context Protocol-specific context (encoded)\n    /// @return ltvBps Current LTV in basis points\n    function getCurrentLtv(\n        bytes4 protocolId,\n        address user,\n        bytes calldata context\n    ) external view returns (uint256 ltvBps);\n\n    /// @notice Get position value for any protocol\n    /// @param protocolId Protocol identifier\n    /// @param user User address\n    /// @param context Protocol-specific context (encoded)\n    /// @return collateralValueUsd Total collateral in 8 decimals USD\n    /// @return debtValueUsd Total debt in 8 decimals USD\n    function getPositionValue(\n        bytes4 protocolId,\n        address user,\n        bytes calldata context\n    ) external view returns (uint256 collateralValueUsd, uint256 debtValueUsd);\n\n    /// @notice Get collateral price for any protocol\n    /// @param protocolId Protocol identifier\n    /// @param collateralToken Collateral token address\n    /// @param context Protocol-specific context (encoded)\n    /// @return price Price in 8 decimals USD\n    function getCollateralPrice(\n        bytes4 protocolId,\n        address collateralToken,\n        bytes calldata context\n    ) external view returns (uint256 price);\n\n    /// @notice Get debt price for any protocol\n    /// @param protocolId Protocol identifier\n    /// @param debtToken Debt token address\n    /// @param context Protocol-specific context (encoded)\n    /// @return price Price in 8 decimals USD\n    function getDebtPrice(\n        bytes4 protocolId,\n        address debtToken,\n        bytes calldata context\n    ) external view returns (uint256 price);\n\n    /// @notice Calculate minimum buy amount with slippage\n    /// @param protocolId Protocol identifier\n    /// @param sellAmount Amount to sell\n    /// @param maxSlippageBps Maximum slippage in basis points\n    /// @param collateralToken Collateral token\n    /// @param debtToken Debt token\n    /// @param collateralDecimals Collateral token decimals\n    /// @param debtDecimals Debt token decimals\n    /// @param context Protocol-specific context\n    /// @return minBuyAmount Minimum acceptable buy amount\n    function calculateMinBuy(\n        bytes4 protocolId,\n        uint256 sellAmount,\n        uint256 maxSlippageBps,\n        address collateralToken,\n        address debtToken,\n        uint8 collateralDecimals,\n        uint8 debtDecimals,\n        bytes calldata context\n    ) external view returns (uint256 minBuyAmount);\n}\n\n/// @title LtvTrigger\n/// @notice Triggers order execution when position LTV exceeds a threshold (ADL)\n/// @dev Calculates deleverage amount to reach target LTV and minimum buy with slippage\ncontract LtvTrigger is IOrderTrigger {\n    // ============ Errors ============\n\n    error UnsupportedProtocol(bytes4 protocolId);\n    error InvalidTriggerParams();\n\n    // ============ Constants ============\n\n    /// @notice Protocol identifiers\n    bytes4 public constant AAVE_V3 = bytes4(keccak256(\"aave-v3\"));\n    bytes4 public constant COMPOUND_V3 = bytes4(keccak256(\"compound-v3\"));\n    bytes4 public constant MORPHO_BLUE = bytes4(keccak256(\"morpho-blue\"));\n    bytes4 public constant EULER_V2 = bytes4(keccak256(\"euler-v2\"));\n    bytes4 public constant VENUS = bytes4(keccak256(\"venus\"));\n\n    // ============ Immutables ============\n\n    /// @notice The KapanViewRouter for LTV and price queries\n    IKapanViewRouter public immutable viewRouter;\n\n    // ============ Structs ============\n\n    /// @notice Trigger parameters for LTV-based ADL\n    struct TriggerParams {\n        bytes4 protocolId; // Protocol identifier (AAVE_V3, COMPOUND_V3, etc.)\n        bytes protocolContext; // Protocol-specific data (market params, sub-account, etc.)\n        uint256 triggerLtvBps; // LTV threshold to trigger (e.g., 8000 = 80%)\n        uint256 targetLtvBps; // Target LTV after deleverage (e.g., 6000 = 60%)\n        address collateralToken; // Token to sell (withdraw from position)\n        address debtToken; // Token to buy (repay debt)\n        uint8 collateralDecimals; // Decimals of collateral token\n        uint8 debtDecimals; // Decimals of debt token\n        uint256 maxSlippageBps; // Maximum slippage tolerance\n        uint8 numChunks; // Number of chunks to split deleverage (1 = full amount, 0 treated as 1)\n    }\n\n    // ============ Constructor ============\n\n    constructor(address _viewRouter) {\n        if (_viewRouter == address(0)) revert InvalidTriggerParams();\n        viewRouter = IKapanViewRouter(_viewRouter);\n    }\n\n    // ============ IOrderTrigger Implementation ============\n\n    /// @inheritdoc IOrderTrigger\n    function shouldExecute(\n        bytes calldata staticData,\n        address owner\n    ) external view override returns (bool, string memory) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        uint256 currentLtv = _getCurrentLtv(params.protocolId, owner, params.protocolContext);\n\n        if (currentLtv == 0) {\n            return (false, \"No position\");\n        }\n\n        if (currentLtv > params.triggerLtvBps) {\n            return (true, \"LTV threshold exceeded\");\n        }\n\n        return (false, \"LTV below threshold\");\n    }\n\n    /// @inheritdoc IOrderTrigger\n    function calculateExecution(\n        bytes calldata staticData,\n        address owner\n    ) external view override returns (uint256 sellAmount, uint256 minBuyAmount) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        // 1. Get current position value in USD (or unit of account)\n        (uint256 collateralValueUsd, uint256 debtValueUsd) = _getPositionValue(\n            params.protocolId,\n            owner,\n            params.protocolContext,\n            params.collateralToken,\n            params.debtToken\n        );\n\n        if (collateralValueUsd == 0 || debtValueUsd == 0) {\n            return (0, 0);\n        }\n\n        // 2. Calculate deleverage amount to reach target LTV\n        // Formula: X = (debt - targetLtv * collateral) / (1 - targetLtv)\n        // Where X is the amount in USD to sell and repay\n        uint256 deleverageUsd = _calculateDeleverageAmount(collateralValueUsd, debtValueUsd, params.targetLtvBps);\n\n        if (deleverageUsd == 0) {\n            return (0, 0);\n        }\n\n        // 3. Convert USD to collateral token amount\n        uint256 collateralPrice = _getCollateralPrice(\n            params.protocolId,\n            params.collateralToken,\n            params.protocolContext\n        );\n\n        if (collateralPrice == 0) {\n            return (0, 0);\n        }\n\n        // sellAmount in collateral token units\n        // deleverageUsd is in 8 decimals (protocol oracle standard)\n        // collateralPrice is in 8 decimals\n        // sellAmount = deleverageUsd * 10^collateralDecimals / collateralPrice\n        sellAmount = (deleverageUsd * (10 ** params.collateralDecimals)) / collateralPrice;\n\n        // 4. Apply chunking - divide by numChunks to spread deleverage across multiple executions\n        // numChunks of 0 or 1 means full amount in single execution\n        if (params.numChunks > 1) {\n            sellAmount = sellAmount / params.numChunks;\n        }\n\n        if (sellAmount == 0) {\n            return (0, 0);\n        }\n\n        // 5. Truncate precision to prevent order spam from interest accrual\n        // Interest-bearing tokens (aTokens, wstETH, etc.) change balance every block.\n        // Without truncation, each poll returns slightly different amounts → different order hash → spam.\n        // We truncate to ~0.01% precision (4 significant decimal places) which absorbs interest fluctuations.\n        sellAmount = _truncatePrecision(sellAmount, params.collateralDecimals);\n\n        if (sellAmount == 0) {\n            return (0, 0);\n        }\n\n        // 6. Calculate minimum buy amount with slippage\n        // ViewRouter.calculateMinBuy uses Aave/Chainlink prices for fair market rates\n        minBuyAmount = _calculateMinBuy(\n            params.protocolId,\n            sellAmount,\n            params.maxSlippageBps,\n            params.collateralToken,\n            params.debtToken,\n            params.collateralDecimals,\n            params.debtDecimals,\n            params.protocolContext\n        );\n\n        // 7. Truncate minBuyAmount as well to prevent spam from price fluctuations\n        minBuyAmount = _truncatePrecision(minBuyAmount, params.debtDecimals);\n    }\n\n    /// @inheritdoc IOrderTrigger\n    /// @dev ADL orders are continuous - they never auto-complete.\n    /// The order remains active and will re-trigger whenever LTV rises above\n    /// the trigger threshold, up to maxIterations or until user cancels.\n    /// This provides ongoing liquidation protection rather than one-shot execution.\n    function isComplete(\n        bytes calldata /* staticData */,\n        address /* owner */,\n        uint256 /* iterationCount */\n    ) external pure override returns (bool) {\n        // Never auto-complete - rely on maxIterations for termination\n        return false;\n    }\n\n    /// @inheritdoc IOrderTrigger\n    function triggerName() external pure override returns (string memory) {\n        return \"LTV\";\n    }\n\n    // ============ View Functions ============\n\n    /// @notice Get current LTV for a user position\n    /// @param protocolId Protocol identifier\n    /// @param owner User address\n    /// @param context Protocol-specific context\n    /// @return ltvBps Current LTV in basis points\n    function getCurrentLtv(\n        bytes4 protocolId,\n        address owner,\n        bytes memory context\n    ) external view returns (uint256 ltvBps) {\n        return _getCurrentLtv(protocolId, owner, context);\n    }\n\n    /// @notice Decode trigger params from static data\n    /// @param staticData ABI-encoded TriggerParams\n    /// @return params Decoded trigger parameters\n    function decodeTriggerParams(bytes calldata staticData) external pure returns (TriggerParams memory params) {\n        return abi.decode(staticData, (TriggerParams));\n    }\n\n    /// @notice Encode trigger params to static data\n    /// @param params Trigger parameters\n    /// @return staticData ABI-encoded data\n    function encodeTriggerParams(TriggerParams calldata params) external pure returns (bytes memory) {\n        return abi.encode(params);\n    }\n\n    // ============ Internal Functions ============\n\n    /// @dev Get current LTV from the ViewRouter (protocol-agnostic)\n    function _getCurrentLtv(bytes4 protocolId, address owner, bytes memory context) internal view returns (uint256) {\n        return viewRouter.getCurrentLtv(protocolId, owner, context);\n    }\n\n    /// @dev Get position value in USD (8 decimals) from the ViewRouter (protocol-agnostic)\n    /// @param protocolId Protocol identifier\n    /// @param owner User address\n    /// @param context Protocol-specific context (market params, base token, etc.)\n    /// @return collateralValueUsd Total collateral value in USD (8 decimals)\n    /// @return debtValueUsd Total debt value in USD (8 decimals)\n    function _getPositionValue(\n        bytes4 protocolId,\n        address owner,\n        bytes memory context,\n        address /* collateralToken */,\n        address /* debtToken */\n    ) internal view returns (uint256 collateralValueUsd, uint256 debtValueUsd) {\n        return viewRouter.getPositionValue(protocolId, owner, context);\n    }\n\n    /// @dev Calculate deleverage amount in USD\n    /// Formula: X = (debt - targetLtv * collateral) / (1 - targetLtv)\n    function _calculateDeleverageAmount(\n        uint256 collateralValueUsd,\n        uint256 debtValueUsd,\n        uint256 targetLtvBps\n    ) internal pure returns (uint256) {\n        // Defensive checks\n        if (collateralValueUsd == 0) {\n            return 0; // No collateral, nothing to deleverage\n        }\n        if (targetLtvBps >= 10000) {\n            return 0; // Invalid target (>= 100%)\n        }\n\n        // Check if already at or below target\n        uint256 currentLtvBps = (debtValueUsd * 10000) / collateralValueUsd;\n        if (currentLtvBps <= targetLtvBps) {\n            return 0;\n        }\n\n        // X = (debt - targetLtv * collateral) / (1 - targetLtv)\n        // All in 8 decimals, targetLtv in basis points\n        uint256 targetDebt = (collateralValueUsd * targetLtvBps) / 10000;\n        uint256 numerator = debtValueUsd - targetDebt;\n        uint256 denominator = 10000 - targetLtvBps;\n\n        return (numerator * 10000) / denominator;\n    }\n\n    /// @dev Get collateral price in USD (8 decimals) from the ViewRouter (protocol-agnostic)\n    function _getCollateralPrice(\n        bytes4 protocolId,\n        address collateralToken,\n        bytes memory context\n    ) internal view returns (uint256) {\n        return viewRouter.getCollateralPrice(protocolId, collateralToken, context);\n    }\n\n    /// @dev Get debt price in USD (8 decimals) from the ViewRouter (protocol-agnostic)\n    function _getDebtPrice(bytes4 protocolId, address debtToken, bytes memory context) internal view returns (uint256) {\n        return viewRouter.getDebtPrice(protocolId, debtToken, context);\n    }\n\n    /// @dev Calculate minimum buy amount with slippage from the ViewRouter (protocol-agnostic)\n    function _calculateMinBuy(\n        bytes4 protocolId,\n        uint256 sellAmount,\n        uint256 maxSlippageBps,\n        address collateralToken,\n        address debtToken,\n        uint8 collateralDecimals,\n        uint8 debtDecimals,\n        bytes memory context\n    ) internal view returns (uint256) {\n        return\n            viewRouter.calculateMinBuy(\n                protocolId,\n                sellAmount,\n                maxSlippageBps,\n                collateralToken,\n                debtToken,\n                collateralDecimals,\n                debtDecimals,\n                context\n            );\n    }\n\n    /// @dev Truncate precision to prevent order spam from interest-bearing tokens\n    /// For tokens like aTokens, wstETH, syrupUSDC - balances change every block due to interest.\n    /// Without truncation, calculateExecution returns slightly different amounts each call,\n    /// causing CoW to see each as a \"new\" order (different hash) → order spam.\n    ///\n    /// Strategy: Truncate based on token decimals to remove the \"noise\" from interest.\n    /// - For 6 decimal tokens (USDC): precision = 10^3 = 1000 (truncate to 0.001 = $0.001)\n    /// - For 18 decimal tokens (ETH): precision = 10^15 (truncate to 0.001 ETH)\n    /// - General: precision = 10^(decimals - 3), keeping 3 decimal places\n    ///\n    /// This absorbs typical interest fluctuations:\n    /// - Daily interest at 10% APY on $1000 = $0.27, but precision = $0.001, so many blocks before change\n    /// - The truncated value stays stable across many blocks\n    ///\n    /// @param amount The amount to truncate\n    /// @param decimals The token's decimals\n    /// @return The truncated amount\n    function _truncatePrecision(uint256 amount, uint8 decimals) internal pure returns (uint256) {\n        if (amount == 0) return 0;\n\n        // Calculate precision: keep 3 decimal places (0.001 in token units)\n        // precision = 10^(decimals - 3) for decimals > 3, otherwise 1\n        uint256 precision = decimals > 3 ? 10 ** (decimals - 3) : 1;\n\n        return (amount / precision) * precision;\n    }\n\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}