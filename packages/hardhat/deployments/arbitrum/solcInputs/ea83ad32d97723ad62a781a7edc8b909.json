{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/v2/interfaces/IOrderTrigger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IOrderTrigger\n/// @notice Interface for pluggable order triggers in the Kapan conditional order system\n/// @dev Triggers determine when an order should execute and how much to trade\ninterface IOrderTrigger {\n    /// @notice Check if the order should execute based on current conditions\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner (user whose position is being monitored)\n    /// @return shouldExecute True if the trigger condition is met\n    /// @return reason Human-readable reason for the result (for debugging/logging)\n    function shouldExecute(\n        bytes calldata staticData,\n        address owner\n    ) external view returns (bool shouldExecute, string memory reason);\n\n    /// @notice Calculate the execution amounts when the trigger fires\n    /// @dev Only called when shouldExecute returns true\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner\n    /// @param iterationCount Number of executions completed so far (for chunked orders)\n    /// @return sellAmount Amount of sell token to trade in this execution\n    /// @return minBuyAmount Minimum amount to receive (includes slippage protection)\n    function calculateExecution(\n        bytes calldata staticData,\n        address owner,\n        uint256 iterationCount\n    ) external view returns (uint256 sellAmount, uint256 minBuyAmount);\n\n    /// @notice Check if the order is complete and should stop executing\n    /// @dev Called after each execution to determine if order should be marked complete\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner\n    /// @param iterationCount Number of executions completed so far\n    /// @return complete True if the order goal has been reached\n    function isComplete(\n        bytes calldata staticData,\n        address owner,\n        uint256 iterationCount\n    ) external view returns (bool complete);\n\n    /// @notice Get human-readable name of the trigger type\n    /// @return name Trigger name (e.g., \"LTV\", \"Price\", \"HealthFactor\")\n    function triggerName() external pure returns (string memory name);\n}\n"
    },
    "contracts/v2/triggers/LimitPriceTrigger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { IOrderTrigger } from \"../interfaces/IOrderTrigger.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title KapanViewRouter Interface (minimal for price queries)\ninterface IKapanViewRouter {\n    function getCollateralPrice(\n        bytes4 protocolId,\n        address collateralToken,\n        bytes calldata context\n    ) external view returns (uint256 price);\n\n    function getDebtPrice(\n        bytes4 protocolId,\n        address debtToken,\n        bytes calldata context\n    ) external view returns (uint256 price);\n}\n\n/// @title LimitPriceTrigger\n/// @notice Triggers order execution when price crosses a limit threshold\n/// @dev Designed for chunked limit orders - executes fixed chunks when price condition is met\n///\n/// Use cases:\n/// - Take profit: Sell when price rises above limit\n/// - Stop loss: Sell when price drops below limit\n/// - DCA buy: Buy when price drops below limit\n///\n/// Chunking:\n/// - totalSellAmount is the full amount to sell across all chunks\n/// - numChunks determines how many iterations\n/// - Each iteration sells totalSellAmount / numChunks\n/// - Last iteration sells remaining to handle rounding\ncontract LimitPriceTrigger is IOrderTrigger {\n    // ============ Errors ============\n    error InvalidTriggerParams();\n\n    // ============ Constants ============\n    bytes4 public constant AAVE_V3 = bytes4(keccak256(\"aave-v3\"));\n    bytes4 public constant COMPOUND_V3 = bytes4(keccak256(\"compound-v3\"));\n    bytes4 public constant MORPHO_BLUE = bytes4(keccak256(\"morpho-blue\"));\n\n    // ============ Immutables ============\n    IKapanViewRouter public immutable viewRouter;\n\n    // ============ Structs ============\n\n    /// @notice Trigger parameters for price-based limit orders\n    struct TriggerParams {\n        bytes4 protocolId;           // Protocol for price oracle\n        bytes protocolContext;       // Protocol-specific context\n        address sellToken;           // Token to sell\n        address buyToken;            // Token to buy\n        uint8 sellDecimals;          // Decimals of sell token\n        uint8 buyDecimals;           // Decimals of buy token\n        uint256 limitPrice;          // Limit price (8 decimals, like Chainlink)\n        bool triggerAbovePrice;      // true = trigger when price >= limit (take profit)\n                                     // false = trigger when price <= limit (stop loss)\n        uint256 totalSellAmount;     // Total amount to sell across all chunks\n        uint8 numChunks;             // Number of chunks (1 = single execution)\n        uint256 maxSlippageBps;      // Maximum slippage tolerance\n    }\n\n    // ============ Constructor ============\n\n    constructor(address _viewRouter) {\n        if (_viewRouter == address(0)) revert InvalidTriggerParams();\n        viewRouter = IKapanViewRouter(_viewRouter);\n    }\n\n    // ============ IOrderTrigger Implementation ============\n\n    /// @inheritdoc IOrderTrigger\n    function shouldExecute(\n        bytes calldata staticData,\n        address owner\n    ) external view override returns (bool, string memory) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        // Check user has tokens to sell\n        uint256 balance = IERC20(params.sellToken).balanceOf(owner);\n        if (balance == 0) {\n            return (false, \"No balance\");\n        }\n\n        // Get current price (sellToken price in USD, 8 decimals)\n        uint256 currentPrice = viewRouter.getCollateralPrice(\n            params.protocolId,\n            params.sellToken,\n            params.protocolContext\n        );\n\n        if (currentPrice == 0) {\n            return (false, \"Price unavailable\");\n        }\n\n        // Check price condition\n        if (params.triggerAbovePrice) {\n            if (currentPrice >= params.limitPrice) {\n                return (true, \"Price above limit\");\n            }\n            return (false, \"Price below limit\");\n        } else {\n            if (currentPrice <= params.limitPrice) {\n                return (true, \"Price below limit\");\n            }\n            return (false, \"Price above limit\");\n        }\n    }\n\n    /// @inheritdoc IOrderTrigger\n    function calculateExecution(\n        bytes calldata staticData,\n        address owner,\n        uint256 iterationCount\n    ) external view override returns (uint256 sellAmount, uint256 minBuyAmount) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        uint8 chunks = params.numChunks > 0 ? params.numChunks : 1;\n\n        // Calculate chunk size\n        uint256 chunkSize = params.totalSellAmount / chunks;\n\n        // For last chunk, use remaining to handle rounding\n        if (iterationCount >= chunks - 1) {\n            // Last chunk: sell everything remaining\n            uint256 alreadySold = iterationCount * chunkSize;\n            sellAmount = params.totalSellAmount > alreadySold\n                ? params.totalSellAmount - alreadySold\n                : 0;\n        } else {\n            sellAmount = chunkSize;\n        }\n\n        // Cap to actual user balance\n        uint256 balance = IERC20(params.sellToken).balanceOf(owner);\n        if (sellAmount > balance) {\n            sellAmount = balance;\n        }\n\n        if (sellAmount == 0) return (0, 0);\n\n        // Truncate precision to prevent order spam\n        sellAmount = _truncatePrecision(sellAmount, params.sellDecimals);\n\n        if (sellAmount == 0) return (0, 0);\n\n        // Calculate minBuyAmount using LIMIT price (guarantees limit or better)\n        // expectedBuy = sellAmount * sellPrice / buyPrice\n        // Using limit price ensures we get at least the limit price\n        uint256 buyPrice = viewRouter.getDebtPrice(\n            params.protocolId,\n            params.buyToken,\n            params.protocolContext\n        );\n\n        if (buyPrice == 0) return (0, 0);\n\n        // expectedBuy = sellAmount * limitPrice / buyPrice\n        // Adjust for decimals: result in buyToken decimals\n        uint256 expectedBuy = (sellAmount * params.limitPrice) / buyPrice;\n        expectedBuy = (expectedBuy * (10 ** params.buyDecimals)) / (10 ** params.sellDecimals);\n\n        // Truncate before slippage\n        expectedBuy = _truncatePrecision(expectedBuy, params.buyDecimals);\n\n        // Apply slippage after truncation\n        minBuyAmount = (expectedBuy * (10000 - params.maxSlippageBps)) / 10000;\n    }\n\n    /// @inheritdoc IOrderTrigger\n    function isComplete(\n        bytes calldata staticData,\n        address owner,\n        uint256 iterationCount\n    ) external view override returns (bool) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        uint8 chunks = params.numChunks > 0 ? params.numChunks : 1;\n\n        // Complete when all chunks executed\n        if (iterationCount >= chunks) {\n            return true;\n        }\n\n        // Also complete if user has no more balance to sell\n        uint256 balance = IERC20(params.sellToken).balanceOf(owner);\n        if (balance == 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @inheritdoc IOrderTrigger\n    function triggerName() external pure override returns (string memory) {\n        return \"LimitPrice\";\n    }\n\n    // ============ View Helpers ============\n\n    /// @notice Get current price for a token\n    function getCurrentPrice(\n        bytes4 protocolId,\n        address token,\n        bytes calldata context\n    ) external view returns (uint256) {\n        return viewRouter.getCollateralPrice(protocolId, token, context);\n    }\n\n    /// @notice Encode trigger params for order creation\n    function encodeTriggerParams(TriggerParams memory params) external pure returns (bytes memory) {\n        return abi.encode(params);\n    }\n\n    /// @notice Decode trigger params from static data\n    function decodeTriggerParams(bytes calldata staticData) external pure returns (TriggerParams memory) {\n        return abi.decode(staticData, (TriggerParams));\n    }\n\n    // ============ Internal Functions ============\n\n    /// @dev Truncate precision to prevent order spam\n    /// Same logic as LtvTrigger/AutoLeverageTrigger for consistency\n    function _truncatePrecision(uint256 amount, uint8 decimals) internal pure returns (uint256) {\n        if (decimals <= 4) return amount;\n        uint256 keep;\n        if (decimals > 12) keep = 5;\n        else if (decimals > 6) keep = 6;\n        else keep = 4;\n        uint256 precision = 10 ** (decimals - keep);\n        return (amount / precision) * precision;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}