{
  "language": "Solidity",
  "sources": {
    "contracts/v2/interfaces/IOrderTrigger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IOrderTrigger\n/// @notice Interface for pluggable order triggers in the Kapan conditional order system\n/// @dev Triggers determine when an order should execute and how much to trade\ninterface IOrderTrigger {\n    /// @notice Check if the order should execute based on current conditions\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner (user whose position is being monitored)\n    /// @return shouldExecute True if the trigger condition is met\n    /// @return reason Human-readable reason for the result (for debugging/logging)\n    function shouldExecute(\n        bytes calldata staticData,\n        address owner\n    ) external view returns (bool shouldExecute, string memory reason);\n\n    /// @notice Calculate the execution amounts when the trigger fires\n    /// @dev Only called when shouldExecute returns true\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner\n    /// @param iterationCount Number of executions completed so far (for chunked orders)\n    /// @return sellAmount Amount of sell token to trade in this execution\n    /// @return minBuyAmount Minimum amount to receive (includes slippage protection)\n    function calculateExecution(\n        bytes calldata staticData,\n        address owner,\n        uint256 iterationCount\n    ) external view returns (uint256 sellAmount, uint256 minBuyAmount);\n\n    /// @notice Check if the order is complete and should stop executing\n    /// @dev Called after each execution to determine if order should be marked complete\n    /// @param staticData ABI-encoded trigger-specific parameters\n    /// @param owner The order owner\n    /// @param iterationCount Number of executions completed so far\n    /// @return complete True if the order goal has been reached\n    function isComplete(\n        bytes calldata staticData,\n        address owner,\n        uint256 iterationCount\n    ) external view returns (bool complete);\n\n    /// @notice Get human-readable name of the trigger type\n    /// @return name Trigger name (e.g., \"LTV\", \"Price\", \"HealthFactor\")\n    function triggerName() external pure returns (string memory name);\n}\n"
    },
    "contracts/v2/triggers/AutoLeverageTrigger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { IOrderTrigger } from \"../interfaces/IOrderTrigger.sol\";\n\n/// @notice Morpho Blue MarketParams structure\nstruct MarketParams {\n    address loanToken;\n    address collateralToken;\n    address oracle;\n    address irm;\n    uint256 lltv;\n}\n\n/// @title KapanViewRouter Interface (same as LtvTrigger)\ninterface IKapanViewRouter {\n    function getCurrentLtv(bytes4 protocolId, address user, bytes calldata context) external view returns (uint256 ltvBps);\n    function getPositionValue(bytes4 protocolId, address user, bytes calldata context) external view returns (uint256 collateralValueUsd, uint256 debtValueUsd);\n    function getCollateralPrice(bytes4 protocolId, address collateralToken, bytes calldata context) external view returns (uint256 price);\n    function getDebtPrice(bytes4 protocolId, address debtToken, bytes calldata context) external view returns (uint256 price);\n    function getMorphoOraclePrice(MarketParams calldata params) external view returns (uint256 price);\n}\n\n/// @title AutoLeverageTrigger\n/// @notice Triggers order execution when position LTV drops BELOW a threshold (auto-leverage)\n/// @dev Opposite of LtvTrigger - increases leverage when under-leveraged\n///\n/// Flow:\n/// 1. Pre-hook: Flash loan collateral → Deposit → Borrow debt → Push to OrderManager\n/// 2. CoW Swap: Debt → Collateral\n/// 3. Post-hook: Repay flash loan with received collateral\n///\n/// Order params:\n///   - sellToken = debtToken (we're selling borrowed debt)\n///   - buyToken = collateralToken (we're buying collateral to repay flash loan)\ncontract AutoLeverageTrigger is IOrderTrigger {\n    // ============ Errors ============\n    error InvalidTriggerParams();\n\n    // ============ Constants ============\n    bytes4 public constant AAVE_V3 = bytes4(keccak256(\"aave-v3\"));\n    bytes4 public constant COMPOUND_V3 = bytes4(keccak256(\"compound-v3\"));\n    bytes4 public constant MORPHO_BLUE = bytes4(keccak256(\"morpho-blue\"));\n    bytes4 public constant EULER_V2 = bytes4(keccak256(\"euler-v2\"));\n    bytes4 public constant VENUS = bytes4(keccak256(\"venus\"));\n\n    // ============ Immutables ============\n    IKapanViewRouter public immutable viewRouter;\n\n    // ============ Structs ============\n\n    /// @notice Trigger parameters for LTV-based auto-leverage\n    struct TriggerParams {\n        bytes4 protocolId;          // Protocol identifier\n        bytes protocolContext;       // Protocol-specific data\n        uint256 triggerLtvBps;       // LTV threshold BELOW which to trigger (e.g., 5000 = 50%)\n        uint256 targetLtvBps;        // Target LTV after leverage (e.g., 7000 = 70%)\n        address collateralToken;     // Token to BUY (receive from swap, repay flash loan)\n        address debtToken;           // Token to SELL (borrow and swap)\n        uint8 collateralDecimals;\n        uint8 debtDecimals;\n        uint256 maxSlippageBps;      // Maximum slippage tolerance\n        uint8 numChunks;             // Number of chunks (1 = full amount)\n    }\n\n    // ============ Constructor ============\n\n    constructor(address _viewRouter) {\n        if (_viewRouter == address(0)) revert InvalidTriggerParams();\n        viewRouter = IKapanViewRouter(_viewRouter);\n    }\n\n    // ============ IOrderTrigger Implementation ============\n\n    /// @inheritdoc IOrderTrigger\n    function shouldExecute(\n        bytes calldata staticData,\n        address owner\n    ) external view override returns (bool, string memory) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        uint256 currentLtv = viewRouter.getCurrentLtv(params.protocolId, owner, params.protocolContext);\n\n        if (currentLtv == 0) {\n            return (false, \"No position\");\n        }\n\n        // Trigger when UNDER-leveraged (LTV too low)\n        if (currentLtv < params.triggerLtvBps) {\n            return (true, \"LTV below threshold - under-leveraged\");\n        }\n\n        return (false, \"LTV above threshold\");\n    }\n\n    /// @inheritdoc IOrderTrigger\n    /// @dev Returns:\n    ///   - sellAmount: debt tokens to borrow and swap\n    ///   - minBuyAmount: collateral tokens expected (must cover flash loan + fee)\n    function calculateExecution(\n        bytes calldata staticData,\n        address owner,\n        uint256 /* iterationCount */\n    ) external view override returns (uint256 sellAmount, uint256 minBuyAmount) {\n        TriggerParams memory params = abi.decode(staticData, (TriggerParams));\n\n        // Get current position value in USD (8 decimals)\n        (uint256 collateralValueUsd, uint256 debtValueUsd) = viewRouter.getPositionValue(\n            params.protocolId,\n            owner,\n            params.protocolContext\n        );\n\n        if (collateralValueUsd == 0) return (0, 0);\n\n        uint256 currentLtv = (debtValueUsd * 10000) / collateralValueUsd;\n        if (currentLtv >= params.targetLtvBps) return (0, 0); // Already at or above target\n\n        // Calculate how much additional debt (in USD) to reach target LTV\n        //\n        // After leverage:\n        //   newDebt / newCollateral = targetLTV\n        //   (D + ΔD) / (C + ΔC) = targetLTV\n        //\n        // Where ΔC ≈ ΔD (collateral received from swapping debt, roughly 1:1 in USD value)\n        //\n        // Solving for ΔD:\n        //   D + ΔD = targetLTV × (C + ΔD)\n        //   D + ΔD = targetLTV × C + targetLTV × ΔD\n        //   ΔD × (1 - targetLTV) = targetLTV × C - D\n        //   ΔD = (targetLTV × C - D) / (1 - targetLTV)\n        //\n        // This is the inverse of the ADL formula (which reduces both C and D)\n        uint256 targetDebtUsd = (params.targetLtvBps * collateralValueUsd) / 10000;\n        if (targetDebtUsd <= debtValueUsd) return (0, 0); // Already at or above target\n\n        uint256 numerator = targetDebtUsd - debtValueUsd;\n        uint256 denominator = 10000 - params.targetLtvBps;\n        if (denominator == 0) return (0, 0); // Prevent division by zero at 100% LTV\n\n        uint256 deltaDebtUsd = (numerator * 10000) / denominator;\n\n        // Convert USD to debt token amount\n        uint256 debtPrice = viewRouter.getDebtPrice(params.protocolId, params.debtToken, params.protocolContext);\n        sellAmount = (deltaDebtUsd * (10 ** params.debtDecimals)) / debtPrice;\n\n        // Apply chunking\n        uint8 chunks = params.numChunks > 0 ? params.numChunks : 1;\n        if (chunks > 1) {\n            sellAmount = sellAmount / chunks;\n        }\n\n        if (sellAmount == 0) return (0, 0);\n\n        // Truncate precision to prevent order spam from interest-bearing tokens\n        // Interest changes cause slightly different amounts each block → different order hash → spam\n        sellAmount = _truncatePrecision(sellAmount, params.debtDecimals);\n\n        if (sellAmount == 0) return (0, 0);\n\n        // Calculate minBuyAmount (collateral) with slippage\n        // This must cover the flash loan repayment\n        uint256 expectedCollateral;\n\n        if (params.protocolId == MORPHO_BLUE) {\n            // Morpho uses a special oracle that returns collateral/debt exchange rate at 36 decimals\n            // Formula: collateralAmount = debtAmount * 1e36 / oraclePrice\n            // The oracle accounts for decimal differences between tokens\n            MarketParams memory marketParams = abi.decode(params.protocolContext, (MarketParams));\n            uint256 morphoOraclePrice = viewRouter.getMorphoOraclePrice(marketParams);\n            if (morphoOraclePrice > 0) {\n                // sellAmount is in debt token decimals, result is in collateral token decimals\n                expectedCollateral = (sellAmount * 1e36) / morphoOraclePrice;\n            }\n        } else {\n            // Standard price-based calculation for other protocols\n            uint256 collateralPrice = viewRouter.getCollateralPrice(\n                params.protocolId,\n                params.collateralToken,\n                params.protocolContext\n            );\n\n            if (collateralPrice > 0) {\n                // Expected collateral = sellAmount(debt) × debtPrice / collateralPrice\n                expectedCollateral = (sellAmount * debtPrice) / collateralPrice;\n                // Adjust for decimals\n                expectedCollateral = (expectedCollateral * (10 ** params.collateralDecimals)) / (10 ** params.debtDecimals);\n            }\n        }\n\n        // Truncate expectedCollateral to prevent spam from price fluctuations\n        // Must truncate BEFORE applying slippage to preserve full slippage protection\n        expectedCollateral = _truncatePrecision(expectedCollateral, params.collateralDecimals);\n\n        // Apply slippage AFTER truncation\n        minBuyAmount = (expectedCollateral * (10000 - params.maxSlippageBps)) / 10000;\n    }\n\n    /// @inheritdoc IOrderTrigger\n    /// @dev Auto-leverage orders are continuous - they never auto-complete.\n    /// The order remains active and will re-trigger whenever LTV drops below\n    /// the trigger threshold, up to maxIterations or until user cancels.\n    /// This provides ongoing leverage management rather than one-shot execution.\n    function isComplete(\n        bytes calldata /* staticData */,\n        address /* owner */,\n        uint256 /* iterationCount */\n    ) external pure override returns (bool) {\n        // Never auto-complete - rely on maxIterations for termination\n        return false;\n    }\n\n    /// @inheritdoc IOrderTrigger\n    function triggerName() external pure override returns (string memory) {\n        return \"AutoLeverage\";\n    }\n\n    // ============ View Helpers ============\n\n    /// @notice Get current LTV for a user\n    function getCurrentLtv(bytes4 protocolId, address owner, bytes calldata context) external view returns (uint256) {\n        return viewRouter.getCurrentLtv(protocolId, owner, context);\n    }\n\n    /// @notice Encode trigger params for order creation\n    function encodeTriggerParams(TriggerParams memory params) external pure returns (bytes memory) {\n        return abi.encode(params);\n    }\n\n    // ============ Internal Functions ============\n\n    /// @dev Truncate precision to prevent order spam from interest accrual\n    /// - 18 decimals (ETH): keep 5 → 0.00001\n    /// - 8 decimals (WBTC): keep 6 → 0.000001\n    /// - 6 decimals (USDC): keep 4 → $0.0001\n    function _truncatePrecision(uint256 amount, uint8 decimals) internal pure returns (uint256) {\n        if (decimals <= 4) return amount;\n        uint256 keep;\n        if (decimals > 12) keep = 5;\n        else if (decimals > 6) keep = 6;\n        else keep = 4;\n        uint256 precision = 10 ** (decimals - keep);\n        return (amount / precision) * precision;\n    }\n\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}