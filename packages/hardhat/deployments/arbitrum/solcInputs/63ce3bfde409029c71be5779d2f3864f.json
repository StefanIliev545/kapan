{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/v2/gateways/euler/EulerGatewayView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { IEulerVault, IEulerPriceOracle } from \"../../interfaces/euler/IEulerVault.sol\";\nimport { IEVC } from \"../../interfaces/euler/IEVC.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title EulerGatewayView\n * @notice Read-only gateway for Euler V2 lending protocol\n * @dev Provides LTV queries and position data for ADL and frontend\n *\n * Sub-Account Model:\n *   - Each user has 256 possible sub-accounts (index 0-255)\n *   - Sub-account address = (userAddress & 0xFF...FF00) | subAccountIndex\n *   - Each sub-account can have at most 1 controller (debt) + N collaterals\n */\ncontract EulerGatewayView {\n    /// @notice The Ethereum Vault Connector (EVC) singleton\n    IEVC public immutable evc;\n\n    error ZeroAddress();\n\n    constructor(address evc_) {\n        if (evc_ == address(0)) revert ZeroAddress();\n        evc = IEVC(evc_);\n    }\n\n    // ============ Sub-Account Helpers ============\n\n    /// @notice Get sub-account address from user and index\n    /// @param user The user's main address\n    /// @param subAccountIndex The sub-account index (0-255)\n    /// @return The sub-account address\n    function getSubAccount(address user, uint8 subAccountIndex) public pure returns (address) {\n        return address(uint160(uint160(user) ^ subAccountIndex));\n    }\n\n    /// @notice Get the user's \"main\" sub-account (index matches last byte of address)\n    /// @param user The user's main address\n    /// @return The main sub-account address and its index\n    function getMainSubAccount(address user) public pure returns (address, uint8) {\n        uint8 mainIndex = uint8(uint160(user) & 0xFF);\n        return (getSubAccount(user, mainIndex), mainIndex);\n    }\n\n    // ============ LTV Queries (for ADL) ============\n\n    /// @notice Returns the current LTV (debt/collateral) in basis points\n    /// @dev Uses Euler's native accountLiquidity function\n    /// @param borrowVault The vault where the user has debt\n    /// @param user The user address\n    /// @param subAccountIndex The sub-account index\n    /// @return Current LTV in basis points (e.g., 6500 = 65%)\n    function getCurrentLtvBps(\n        address borrowVault,\n        address user,\n        uint8 subAccountIndex\n    ) external view returns (uint256) {\n        address subAccount = getSubAccount(user, subAccountIndex);\n\n        // Get account liquidity using liquidation=false (borrow LTV)\n        // collateralValue is already LTV-adjusted, so we need raw values\n        // Use liquidation=true to get values closer to raw (higher LTV means less adjustment)\n        (uint256 collateralValueLiq, uint256 liabilityValue) = IEulerVault(borrowVault).accountLiquidity(subAccount, true);\n\n        if (collateralValueLiq == 0 || liabilityValue == 0) return 0;\n\n        // accountLiquidity returns collateral adjusted by LLTV, so:\n        // rawCollateral ≈ collateralValueLiq / LLTV\n        // currentLTV = liability / rawCollateral = liability * LLTV / collateralValueLiq\n\n        // Get the effective LLTV (minimum across all collaterals)\n        address[] memory collaterals = IEulerVault(borrowVault).LTVList();\n        uint256 minLltv = 10000; // Default to 100% if no collaterals\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            uint16 lltv = IEulerVault(borrowVault).LTVLiquidation(collaterals[i]);\n            if (lltv > 0 && lltv < minLltv) {\n                minLltv = lltv;\n            }\n        }\n\n        // currentLTV (bps) = (liability * LLTV) / collateralValueLiq\n        // Since LLTV is already in 1e4 scale (bps), and we want result in bps:\n        // currentLTV = (liability * 10000) / collateralValueLiq * (10000 / LLTV)\n        // Simplified: currentLTV = (liability * 10000 * 10000) / (collateralValueLiq * LLTV)\n\n        if (minLltv == 0) return 0;\n        return (liabilityValue * 10000 * 10000) / (collateralValueLiq * minLltv);\n    }\n\n    /// @notice Returns the current LTV using raw collateral/liability values\n    /// @dev Alternative calculation that doesn't rely on LLTV adjustment\n    /// @param borrowVault The vault where the user has debt\n    /// @param user The user address\n    /// @param subAccountIndex The sub-account index\n    /// @return Current LTV in basis points\n    function getCurrentLtvBpsSimple(\n        address borrowVault,\n        address user,\n        uint8 subAccountIndex\n    ) external view returns (uint256) {\n        address subAccount = getSubAccount(user, subAccountIndex);\n\n        // Get detailed liquidity to sum raw collateral values\n        (\n            address[] memory collaterals,\n            uint256[] memory collateralValues,\n            uint256 liabilityValue\n        ) = IEulerVault(borrowVault).accountLiquidityFull(subAccount, true);\n\n        if (liabilityValue == 0) return 0;\n\n        // Sum raw collateral values (un-adjust by dividing by LLTV)\n        uint256 rawCollateralValue = 0;\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collateralValues[i] > 0) {\n                uint16 lltv = IEulerVault(borrowVault).LTVLiquidation(collaterals[i]);\n                if (lltv > 0) {\n                    // rawValue = adjustedValue * 10000 / LLTV\n                    rawCollateralValue += (collateralValues[i] * 10000) / lltv;\n                }\n            }\n        }\n\n        if (rawCollateralValue == 0) return 0;\n\n        // currentLTV = liability / rawCollateral * 10000\n        return (liabilityValue * 10000) / rawCollateralValue;\n    }\n\n    /// @notice Returns the liquidation LTV threshold in basis points\n    /// @dev Returns the minimum LLTV across all enabled collaterals\n    /// @param borrowVault The vault where the user has debt\n    /// @return Minimum liquidation threshold in basis points\n    function getLiquidationLtvBps(address borrowVault) external view returns (uint256) {\n        address[] memory collaterals = IEulerVault(borrowVault).LTVList();\n        if (collaterals.length == 0) return 0;\n\n        uint256 minLltv = type(uint256).max;\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            uint16 lltv = IEulerVault(borrowVault).LTVLiquidation(collaterals[i]);\n            if (lltv > 0 && lltv < minLltv) {\n                minLltv = lltv;\n            }\n        }\n\n        return minLltv == type(uint256).max ? 0 : minLltv;\n    }\n\n    /// @notice Returns the borrow LTV limit in basis points\n    /// @dev Returns the minimum borrow LTV across all enabled collaterals\n    /// @param borrowVault The vault where the user has debt\n    /// @return Minimum borrow LTV in basis points\n    function getBorrowLtvBps(address borrowVault) external view returns (uint256) {\n        address[] memory collaterals = IEulerVault(borrowVault).LTVList();\n        if (collaterals.length == 0) return 0;\n\n        uint256 minLtv = type(uint256).max;\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            uint16 ltv = IEulerVault(borrowVault).LTVBorrow(collaterals[i]);\n            if (ltv > 0 && ltv < minLtv) {\n                minLtv = ltv;\n            }\n        }\n\n        return minLtv == type(uint256).max ? 0 : minLtv;\n    }\n\n    // ============ Position Queries ============\n\n    /// @notice Check if a position is healthy (not liquidatable)\n    /// @param borrowVault The vault where the user has debt\n    /// @param user The user address\n    /// @param subAccountIndex The sub-account index\n    /// @return True if position is healthy\n    function isHealthy(\n        address borrowVault,\n        address user,\n        uint8 subAccountIndex\n    ) external view returns (bool) {\n        address subAccount = getSubAccount(user, subAccountIndex);\n        (uint256 collateralValue, uint256 liabilityValue) = IEulerVault(borrowVault).accountLiquidity(subAccount, true);\n\n        // Position is healthy if collateralValue >= liabilityValue (using liquidation LTV)\n        return collateralValue >= liabilityValue;\n    }\n\n    /// @notice Get health factor (collateral / liability ratio)\n    /// @param borrowVault The vault where the user has debt\n    /// @param user The user address\n    /// @param subAccountIndex The sub-account index\n    /// @return Health factor in 1e18 scale (1e18 = 1.0)\n    function getHealthFactor(\n        address borrowVault,\n        address user,\n        uint8 subAccountIndex\n    ) external view returns (uint256) {\n        address subAccount = getSubAccount(user, subAccountIndex);\n        (uint256 collateralValue, uint256 liabilityValue) = IEulerVault(borrowVault).accountLiquidity(subAccount, true);\n\n        if (liabilityValue == 0) return type(uint256).max;\n        return (collateralValue * 1e18) / liabilityValue;\n    }\n\n    /// @notice Get debt balance for a sub-account\n    /// @param borrowVault The vault where the user has debt\n    /// @param user The user address\n    /// @param subAccountIndex The sub-account index\n    /// @return Debt in underlying asset units\n    function getDebtBalance(\n        address borrowVault,\n        address user,\n        uint8 subAccountIndex\n    ) external view returns (uint256) {\n        address subAccount = getSubAccount(user, subAccountIndex);\n        return IEulerVault(borrowVault).debtOf(subAccount);\n    }\n\n    /// @notice Get collateral balance for a sub-account in a specific vault\n    /// @param collateralVault The vault where collateral is deposited\n    /// @param user The user address\n    /// @param subAccountIndex The sub-account index\n    /// @return Collateral in underlying asset units\n    function getCollateralBalance(\n        address collateralVault,\n        address user,\n        uint8 subAccountIndex\n    ) external view returns (uint256) {\n        address subAccount = getSubAccount(user, subAccountIndex);\n        return IEulerVault(collateralVault).maxWithdraw(subAccount);\n    }\n\n    // ============ Vault Info ============\n\n    /// @notice Get vault's underlying asset\n    /// @param vault The vault address\n    /// @return The underlying asset address\n    function getVaultAsset(address vault) external view returns (address) {\n        return IEulerVault(vault).asset();\n    }\n\n    /// @notice Get vault's name\n    /// @param vault The vault address\n    /// @return The vault name\n    function getVaultName(address vault) external view returns (string memory) {\n        return IEulerVault(vault).name();\n    }\n\n    /// @notice Get vault's symbol\n    /// @param vault The vault address\n    /// @return The vault symbol\n    function getVaultSymbol(address vault) external view returns (string memory) {\n        return IEulerVault(vault).symbol();\n    }\n\n    /// @notice Get list of accepted collaterals for a borrow vault\n    /// @param borrowVault The borrow vault address\n    /// @return Array of collateral vault addresses with configured LTVs\n    function getAcceptedCollaterals(address borrowVault) external view returns (address[] memory) {\n        return IEulerVault(borrowVault).LTVList();\n    }\n\n    /// @notice Get LTV configuration for a specific collateral\n    /// @param borrowVault The borrow vault address\n    /// @param collateralVault The collateral vault address\n    /// @return borrowLTV The borrow LTV in basis points\n    /// @return liquidationLTV The liquidation LTV in basis points\n    function getCollateralLtv(\n        address borrowVault,\n        address collateralVault\n    ) external view returns (uint256 borrowLTV, uint256 liquidationLTV) {\n        borrowLTV = IEulerVault(borrowVault).LTVBorrow(collateralVault);\n        liquidationLTV = IEulerVault(borrowVault).LTVLiquidation(collateralVault);\n    }\n\n    // ============ Position Value Queries (for ADL/AL) ============\n\n    /// @notice Get total collateral and debt values in USD (8 decimals)\n    /// @dev Used by ADL/AL triggers to calculate position values\n    /// @param borrowVault The vault where the user has debt\n    /// @param user The user address\n    /// @param subAccountIndex The sub-account index\n    /// @return totalCollateralUsd Total collateral value in 8 decimals USD\n    /// @return totalDebtUsd Total debt value in 8 decimals USD\n    function getUserAccountData(\n        address borrowVault,\n        address user,\n        uint8 subAccountIndex\n    ) external view returns (uint256 totalCollateralUsd, uint256 totalDebtUsd) {\n        address subAccount = getSubAccount(user, subAccountIndex);\n\n        // Get raw collateral and liability values from Euler\n        // Using liquidation=false to get borrow-adjusted values\n        (\n            address[] memory collaterals,\n            uint256[] memory collateralValues,\n            uint256 liabilityValue\n        ) = IEulerVault(borrowVault).accountLiquidityFull(subAccount, false);\n\n        // Sum raw collateral values (un-adjust by dividing by borrow LTV)\n        uint256 rawCollateralValue = 0;\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collateralValues[i] > 0) {\n                uint16 ltv = IEulerVault(borrowVault).LTVBorrow(collaterals[i]);\n                if (ltv > 0) {\n                    // rawValue = adjustedValue * 10000 / LTV\n                    rawCollateralValue += (collateralValues[i] * 10000) / ltv;\n                }\n            }\n        }\n\n        // Get unit of account decimals to convert to 8 decimals (Chainlink format)\n        address unitOfAccount = IEulerVault(borrowVault).unitOfAccount();\n        uint8 uoaDecimals = 18; // Default to 18 if we can't get decimals\n        if (unitOfAccount != address(0)) {\n            try IERC20Metadata(unitOfAccount).decimals() returns (uint8 d) {\n                uoaDecimals = d;\n            } catch {}\n        }\n\n        // Convert from unit of account decimals to 8 decimals\n        if (uoaDecimals > 8) {\n            uint256 divisor = 10 ** (uoaDecimals - 8);\n            totalCollateralUsd = rawCollateralValue / divisor;\n            totalDebtUsd = liabilityValue / divisor;\n        } else if (uoaDecimals < 8) {\n            uint256 multiplier = 10 ** (8 - uoaDecimals);\n            totalCollateralUsd = rawCollateralValue * multiplier;\n            totalDebtUsd = liabilityValue * multiplier;\n        } else {\n            totalCollateralUsd = rawCollateralValue;\n            totalDebtUsd = liabilityValue;\n        }\n    }\n\n    // ============ Price Queries (for ADL) ============\n\n    /// @notice Get exchange rate between two tokens via vault's oracle\n    /// @dev Returns how many quote tokens you get for 1 whole unit of base token\n    /// @param vault Any vault that has the oracle configured\n    /// @param baseToken The token to price (e.g., WETH)\n    /// @param quoteToken The unit of account (e.g., USDC)\n    /// @return rate Exchange rate scaled by quoteToken decimals\n    function getExchangeRate(\n        address vault,\n        address baseToken,\n        address quoteToken\n    ) external view returns (uint256 rate) {\n        address oracle = IEulerVault(vault).oracle();\n        if (oracle == address(0)) return 0;\n\n        // Get 1 whole unit of base token\n        uint8 baseDecimals = IERC20Metadata(baseToken).decimals();\n        uint256 oneUnit = 10 ** baseDecimals;\n\n        try IEulerPriceOracle(oracle).getQuote(oneUnit, baseToken, quoteToken) returns (uint256 quote) {\n            return quote;\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice Get price of a token in the vault's unit of account\n    /// @dev Returns the value of 1 whole unit of token\n    /// @param vault The vault to query (determines oracle and unit of account)\n    /// @param token The token to price\n    /// @return price Price in unit of account decimals\n    function getAssetPrice(\n        address vault,\n        address token\n    ) external view returns (uint256 price) {\n        address oracle = IEulerVault(vault).oracle();\n        address unitOfAccount = IEulerVault(vault).unitOfAccount();\n        if (oracle == address(0) || unitOfAccount == address(0)) return 0;\n\n        uint8 tokenDecimals = IERC20Metadata(token).decimals();\n        uint256 oneUnit = 10 ** tokenDecimals;\n\n        try IEulerPriceOracle(oracle).getQuote(oneUnit, token, unitOfAccount) returns (uint256 quote) {\n            return quote;\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice Get exchange rate between collateral and debt token for a position\n    /// @dev Useful for ADL: how many debt tokens per collateral token\n    /// @param borrowVault The borrow vault (debt side)\n    /// @param collateralVault The collateral vault\n    /// @return rate18 Exchange rate with 18 decimals (collateral → debt)\n    function getCollateralToDebtRate(\n        address borrowVault,\n        address collateralVault\n    ) external view returns (uint256 rate18) {\n        address oracle = IEulerVault(borrowVault).oracle();\n        address unitOfAccount = IEulerVault(borrowVault).unitOfAccount();\n        if (oracle == address(0) || unitOfAccount == address(0)) return 0;\n\n        address collateralAsset = IEulerVault(collateralVault).asset();\n        address debtAsset = IEulerVault(borrowVault).asset();\n\n        uint8 collateralDecimals = IERC20Metadata(collateralAsset).decimals();\n        uint8 debtDecimals = IERC20Metadata(debtAsset).decimals();\n\n        // Get value of 1 collateral in unit of account\n        uint256 oneCollateral = 10 ** collateralDecimals;\n        uint256 collateralValue;\n        try IEulerPriceOracle(oracle).getQuote(oneCollateral, collateralAsset, unitOfAccount) returns (uint256 v) {\n            collateralValue = v;\n        } catch {\n            return 0;\n        }\n\n        // Get value of 1 debt token in unit of account\n        uint256 oneDebt = 10 ** debtDecimals;\n        uint256 debtValue;\n        try IEulerPriceOracle(oracle).getQuote(oneDebt, debtAsset, unitOfAccount) returns (uint256 v) {\n            debtValue = v;\n        } catch {\n            return 0;\n        }\n\n        if (debtValue == 0) return 0;\n\n        // exchangeRate = collateralValue / debtValue (how many debt tokens per collateral)\n        // Scale to 18 decimals\n        return (collateralValue * 1e18) / debtValue;\n    }\n}\n"
    },
    "contracts/v2/interfaces/euler/IEulerVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IEulerVault\n/// @notice Interface for Euler V2 vaults (EVK - Euler Vault Kit)\n/// @dev Extends ERC-4626 with borrowing functionality\ninterface IEulerVault {\n    // ============ ERC-4626 Standard Functions ============\n\n    /// @notice The underlying asset of the vault\n    function asset() external view returns (address);\n\n    /// @notice Total assets held by the vault\n    function totalAssets() external view returns (uint256);\n\n    /// @notice Convert assets to shares\n    function convertToShares(uint256 assets) external view returns (uint256);\n\n    /// @notice Convert shares to assets\n    function convertToAssets(uint256 shares) external view returns (uint256);\n\n    /// @notice Deposit assets and receive shares\n    /// @param assets Amount of assets to deposit\n    /// @param receiver Address to receive shares\n    /// @return shares Amount of shares minted\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /// @notice Withdraw assets by burning shares\n    /// @param assets Amount of assets to withdraw\n    /// @param receiver Address to receive assets\n    /// @param owner Address whose shares will be burned\n    /// @return shares Amount of shares burned\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /// @notice Redeem shares for assets\n    /// @param shares Amount of shares to redeem\n    /// @param receiver Address to receive assets\n    /// @param owner Address whose shares will be burned\n    /// @return assets Amount of assets received\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n\n    /// @notice Get share balance of an account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Maximum withdrawable assets for an owner\n    function maxWithdraw(address owner) external view returns (uint256);\n\n    /// @notice Maximum redeemable shares for an owner\n    function maxRedeem(address owner) external view returns (uint256);\n\n    // ============ EVK Borrowing Extensions ============\n\n    /// @notice Borrow assets from the vault\n    /// @param assets Amount of assets to borrow\n    /// @param receiver Address to receive borrowed assets\n    /// @return Amount actually borrowed\n    function borrow(uint256 assets, address receiver) external returns (uint256);\n\n    /// @notice Repay borrowed assets\n    /// @param assets Amount of assets to repay\n    /// @param receiver Address of the borrower whose debt to repay\n    /// @return Amount actually repaid\n    function repay(uint256 assets, address receiver) external returns (uint256);\n\n    /// @notice Get debt balance of an account\n    /// @param account Address to query\n    /// @return Amount of debt in asset units\n    function debtOf(address account) external view returns (uint256);\n\n    /// @notice Get debt balance in shares\n    /// @param account Address to query\n    /// @return Amount of debt shares\n    function debtOfExact(address account) external view returns (uint256);\n\n    /// @notice Total borrowed assets\n    function totalBorrows() external view returns (uint256);\n\n    // ============ Interest Rate ============\n\n    /// @notice Current interest rate\n    function interestRate() external view returns (uint256);\n\n    /// @notice Interest accumulator for debt calculation\n    function interestAccumulator() external view returns (uint256);\n\n    // ============ LTV Configuration ============\n\n    /// @notice Get the borrow LTV for a collateral (max LTV for new borrows)\n    /// @param collateral The collateral vault address\n    /// @return Borrow LTV in 1e4 scale (8000 = 80%)\n    function LTVBorrow(address collateral) external view returns (uint16);\n\n    /// @notice Get the liquidation LTV for a collateral (LLTV threshold)\n    /// @param collateral The collateral vault address\n    /// @return Liquidation LTV in 1e4 scale (9000 = 90%)\n    function LTVLiquidation(address collateral) external view returns (uint16);\n\n    /// @notice Get full LTV configuration including ramping parameters\n    /// @param collateral The collateral vault address\n    /// @return borrowLTV The borrow LTV\n    /// @return liquidationLTV The current liquidation LTV\n    /// @return initialLiquidationLTV The initial liquidation LTV before ramping\n    /// @return targetTimestamp When ramping completes\n    /// @return rampDuration Duration of the ramp\n    function LTVFull(address collateral) external view returns (\n        uint16 borrowLTV,\n        uint16 liquidationLTV,\n        uint16 initialLiquidationLTV,\n        uint48 targetTimestamp,\n        uint32 rampDuration\n    );\n\n    /// @notice Get list of all collaterals with configured LTVs\n    /// @return Array of collateral vault addresses\n    function LTVList() external view returns (address[] memory);\n\n    // ============ Account Liquidity ============\n\n    /// @notice Get account liquidity (health check)\n    /// @param account The account to check\n    /// @param liquidation If true, use liquidation LTV; if false, use borrow LTV\n    /// @return collateralValue Total collateral value in unit of account\n    /// @return liabilityValue Total liability value in unit of account\n    function accountLiquidity(address account, bool liquidation)\n        external view returns (uint256 collateralValue, uint256 liabilityValue);\n\n    /// @notice Get detailed account liquidity per collateral\n    /// @param account The account to check\n    /// @param liquidation If true, use liquidation LTV; if false, use borrow LTV\n    /// @return collaterals Array of collateral addresses\n    /// @return collateralValues Array of collateral values\n    /// @return liabilityValue Total liability value\n    function accountLiquidityFull(address account, bool liquidation)\n        external view returns (\n            address[] memory collaterals,\n            uint256[] memory collateralValues,\n            uint256 liabilityValue\n        );\n\n    // ============ Controller Management ============\n\n    /// @notice Disable this vault as controller for the authenticated account\n    /// @dev Must be called through EVC.call() with proper onBehalfOfAccount context\n    ///      Reverts if the account has outstanding debt to this vault\n    function disableController() external;\n\n    // ============ Vault Info ============\n\n    /// @notice Name of the vault token\n    function name() external view returns (string memory);\n\n    /// @notice Symbol of the vault token\n    function symbol() external view returns (string memory);\n\n    /// @notice Decimals of the vault token\n    function decimals() external view returns (uint8);\n\n    // ============ Oracle & Unit of Account ============\n\n    /// @notice Get the price oracle for this vault\n    function oracle() external view returns (address);\n\n    /// @notice Get the unit of account (e.g., USD, ETH)\n    function unitOfAccount() external view returns (address);\n}\n\n/// @title IEulerPriceOracle\n/// @notice Interface for Euler's price oracle system\ninterface IEulerPriceOracle {\n    /// @notice Get a quote for swapping base to quote tokens\n    /// @param inAmount Amount of base tokens\n    /// @param base The base token address\n    /// @param quote The quote token address (unit of account)\n    /// @return outAmount Amount of quote tokens\n    function getQuote(\n        uint256 inAmount,\n        address base,\n        address quote\n    ) external view returns (uint256 outAmount);\n\n    /// @notice Get both bid and ask quotes\n    /// @param inAmount Amount of base tokens\n    /// @param base The base token address\n    /// @param quote The quote token address\n    /// @return bidOutAmount Amount at bid price\n    /// @return askOutAmount Amount at ask price\n    function getQuotes(\n        uint256 inAmount,\n        address base,\n        address quote\n    ) external view returns (uint256 bidOutAmount, uint256 askOutAmount);\n}\n"
    },
    "contracts/v2/interfaces/euler/IEVC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IEVC\n/// @notice Interface for the Ethereum Vault Connector (EVC)\n/// @dev The EVC mediates between vaults in the Euler V2 protocol\ninterface IEVC {\n    /// @notice Batch operation item\n    struct BatchItem {\n        address targetContract;\n        address onBehalfOfAccount;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Execute a batch of operations\n    /// @param items Array of batch items to execute\n    function batch(BatchItem[] calldata items) external payable;\n\n    /// @notice Execute a call on behalf of an account\n    /// @param targetContract The contract to call\n    /// @param onBehalfOfAccount The account context for the call\n    /// @param value ETH value to send\n    /// @param data The calldata to execute\n    /// @return result The return data from the call\n    function call(\n        address targetContract,\n        address onBehalfOfAccount,\n        uint256 value,\n        bytes calldata data\n    ) external payable returns (bytes memory result);\n\n    /// @notice Enable a vault as collateral for an account\n    /// @param account The account to enable collateral for\n    /// @param vault The vault to enable as collateral\n    function enableCollateral(address account, address vault) external;\n\n    /// @notice Disable a vault as collateral for an account\n    /// @param account The account to disable collateral for\n    /// @param vault The vault to disable as collateral\n    function disableCollateral(address account, address vault) external;\n\n    /// @notice Enable a vault as controller for an account (allows borrowing)\n    /// @param account The account to enable controller for\n    /// @param vault The vault to enable as controller\n    function enableController(address account, address vault) external;\n\n    /// @notice Disable controller for an account\n    /// @dev Will revert if account has outstanding debt\n    /// @param account The account to disable controller for\n    function disableController(address account) external;\n\n    /// @notice Check if a vault is enabled as collateral for an account\n    /// @param account The account to check\n    /// @param vault The vault to check\n    /// @return True if the vault is enabled as collateral\n    function isCollateralEnabled(address account, address vault) external view returns (bool);\n\n    /// @notice Check if a vault is enabled as controller for an account\n    /// @param account The account to check\n    /// @param vault The vault to check\n    /// @return True if the vault is enabled as controller\n    function isControllerEnabled(address account, address vault) external view returns (bool);\n\n    /// @notice Get all collateral vaults for an account\n    /// @param account The account to query\n    /// @return Array of vault addresses enabled as collateral\n    function getCollaterals(address account) external view returns (address[] memory);\n\n    /// @notice Get all controller vaults for an account\n    /// @param account The account to query\n    /// @return Array of vault addresses enabled as controller\n    function getControllers(address account) external view returns (address[] memory);\n\n    /// @notice Set or revoke an operator for an account\n    /// @param account The account to set operator for\n    /// @param operator The operator address\n    /// @param authorized True to authorize, false to revoke\n    function setAccountOperator(address account, address operator, bool authorized) external;\n\n    /// @notice Check if an operator is authorized for an account\n    /// @param account The account to check\n    /// @param operator The operator to check\n    /// @return True if the operator is authorized\n    function isAccountOperatorAuthorized(address account, address operator) external view returns (bool);\n\n    /// @notice Get the owner of an account (handles sub-accounts)\n    /// @param account The account address\n    /// @return The owner address\n    function getAccountOwner(address account) external view returns (address);\n}\n"
    },
    "contracts/v2/interfaces/morpho/IMorphoBlue.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IMorphoBlue Interface\n/// @notice Interface for Morpho Blue lending protocol\n/// @dev See https://github.com/morpho-org/morpho-blue\n\nstruct MarketParams {\n    address loanToken;\n    address collateralToken;\n    address oracle;\n    address irm;\n    uint256 lltv;\n}\n\nstruct Market {\n    uint128 totalSupplyAssets;\n    uint128 totalSupplyShares;\n    uint128 totalBorrowAssets;\n    uint128 totalBorrowShares;\n    uint128 lastUpdate;\n    uint128 fee;\n}\n\nstruct Position {\n    uint256 supplyShares;\n    uint128 borrowShares;\n    uint128 collateral;\n}\n\ninterface IMorphoBlue {\n    /// @notice The state of a market (by id)\n    function market(bytes32 id) external view returns (Market memory);\n\n    /// @notice The position of a user in a market\n    function position(bytes32 id, address user) external view returns (Position memory);\n\n    /// @notice Whether an address is authorized to act on behalf of another\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\n\n    /// @notice The nonce of an authorizer for EIP-712 signatures\n    function nonce(address authorizer) external view returns (uint256);\n\n    /// @notice Compute market ID from market params\n    function idToMarketParams(bytes32 id) external view returns (MarketParams memory);\n\n    // ============ Write Functions ============\n\n    /// @notice Supply assets to a market (lender side - earns yield)\n    /// @param marketParams The market to supply to\n    /// @param assets The amount of assets to supply (use 0 if using shares)\n    /// @param shares The amount of shares to mint (use 0 if using assets)\n    /// @param onBehalf The address to supply on behalf of\n    /// @param data Callback data (empty for no callback)\n    /// @return assetsSupplied The actual amount of assets supplied\n    /// @return sharesSupplied The actual amount of shares minted\n    function supply(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\n\n    /// @notice Withdraw assets from a market (lender side)\n    /// @param marketParams The market to withdraw from\n    /// @param assets The amount of assets to withdraw (use 0 if using shares)\n    /// @param shares The amount of shares to burn (use 0 if using assets)\n    /// @param onBehalf The address to withdraw on behalf of\n    /// @param receiver The address to receive the withdrawn assets\n    /// @return assetsWithdrawn The actual amount of assets withdrawn\n    /// @return sharesWithdrawn The actual amount of shares burned\n    function withdraw(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\n\n    /// @notice Borrow assets from a market\n    /// @param marketParams The market to borrow from\n    /// @param assets The amount of assets to borrow (use 0 if using shares)\n    /// @param shares The amount of borrow shares to mint (use 0 if using assets)\n    /// @param onBehalf The address to borrow on behalf of\n    /// @param receiver The address to receive the borrowed assets\n    /// @return assetsBorrowed The actual amount of assets borrowed\n    /// @return sharesBorrowed The actual amount of borrow shares minted\n    function borrow(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\n\n    /// @notice Repay borrowed assets\n    /// @param marketParams The market to repay to\n    /// @param assets The amount of assets to repay (use 0 if using shares)\n    /// @param shares The amount of borrow shares to burn (use 0 if using assets)\n    /// @param onBehalf The address to repay on behalf of\n    /// @param data Callback data (empty for no callback)\n    /// @return assetsRepaid The actual amount of assets repaid\n    /// @return sharesRepaid The actual amount of borrow shares burned\n    function repay(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\n\n    /// @notice Supply collateral to a market\n    /// @param marketParams The market to supply collateral to\n    /// @param assets The amount of collateral assets to supply\n    /// @param onBehalf The address to supply on behalf of\n    /// @param data Callback data (empty for no callback)\n    function supplyCollateral(\n        MarketParams memory marketParams,\n        uint256 assets,\n        address onBehalf,\n        bytes memory data\n    ) external;\n\n    /// @notice Withdraw collateral from a market\n    /// @param marketParams The market to withdraw collateral from\n    /// @param assets The amount of collateral assets to withdraw\n    /// @param onBehalf The address to withdraw on behalf of\n    /// @param receiver The address to receive the withdrawn collateral\n    function withdrawCollateral(\n        MarketParams memory marketParams,\n        uint256 assets,\n        address onBehalf,\n        address receiver\n    ) external;\n\n    /// @notice Set authorization for an address to act on behalf of the caller\n    /// @param authorized The address to authorize/deauthorize\n    /// @param newIsAuthorized Whether to authorize (true) or deauthorize (false)\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\n\n    /// @notice Set authorization with signature (EIP-712)\n    function setAuthorizationWithSig(\n        address authorizer,\n        address authorized,\n        bool newIsAuthorized,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /// @notice Accrue interest for a market\n    function accrueInterest(MarketParams memory marketParams) external;\n\n    /// @notice Executes a flash loan.\n    /// @dev Flash loans have access to the whole balance of the contract (all markets combined).\n    /// @dev Zero fees - flashFee is always zero.\n    /// @param token The token to flash loan.\n    /// @param assets The amount of assets to flash loan.\n    /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\n    function flashLoan(address token, uint256 assets, bytes calldata data) external;\n}\n\n/// @title IMorphoFlashLoanCallback\n/// @notice Interface that users willing to use `flashLoan`'s callback must implement.\ninterface IMorphoFlashLoanCallback {\n    /// @notice Callback called when a flash loan occurs.\n    /// @param assets The amount of assets that was flash loaned.\n    /// @param data Arbitrary data passed to the `flashLoan` function.\n    function onMorphoFlashLoan(uint256 assets, bytes calldata data) external;\n}\n\n/// @notice Library for computing Morpho Blue market IDs\nlibrary MorphoLib {\n    /// @notice Compute the market ID from market params\n    function id(MarketParams memory params) internal pure returns (bytes32) {\n        return keccak256(abi.encode(params));\n    }\n}\n\n"
    },
    "contracts/v2/KapanViewRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { MarketParams } from \"./interfaces/morpho/IMorphoBlue.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title Gateway View Interfaces\n * @notice Minimal interfaces for LTV queries on each protocol's gateway view\n */\n\ninterface IAaveGatewayView {\n    function getCurrentLtvBps(address market, address user) external view returns (uint256);\n    function getLiquidationLtvBps(address market, address user) external view returns (uint256);\n    function getAssetPrice(address token) external view returns (uint256);\n    function getAssetPrices(address[] calldata tokens) external view returns (uint256[] memory);\n    function getUserAccountData(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n}\n\ninterface ICompoundGatewayView {\n    function getCurrentLtvBps(address token, address user) external view returns (uint256);\n    function getLiquidationLtvBps(address token, address user) external view returns (uint256);\n    function getPrice(address token) external view returns (uint256);\n    function getCollateralPrice(address market, address asset) external view returns (uint256);\n    function getPositionValue(\n        address market,\n        address user\n    ) external view returns (uint256 collateralValueUsd, uint256 debtValueUsd);\n}\n\ninterface IMorphoBlueGatewayView {\n    function getCurrentLtvBps(MarketParams calldata params, address user) external view returns (uint256);\n    function getLiquidationLtvBps(MarketParams calldata params) external view returns (uint256);\n    function getOraclePrice(MarketParams calldata params) external view returns (uint256);\n    function getPositionValue(\n        MarketParams calldata params,\n        address user\n    ) external view returns (uint256 collateralValueUsd, uint256 debtValueUsd);\n}\n\ninterface IEulerGatewayView {\n    function getCurrentLtvBps(address vault, address user, uint8 subAccountIndex) external view returns (uint256);\n    function getLiquidationLtvBps(address vault) external view returns (uint256);\n    function getAssetPrice(address vault, address token) external view returns (uint256);\n    function getCollateralToDebtRate(address borrowVault, address collateralVault) external view returns (uint256);\n    function getUserAccountData(address borrowVault, address user, uint8 subAccountIndex) external view returns (uint256 totalCollateralUsd, uint256 totalDebtUsd);\n}\n\ninterface IVenusGatewayView {\n    function getCurrentLtvBps(address market, address user) external view returns (uint256);\n    function getLiquidationLtvBps(address market, address user) external view returns (uint256);\n    function getAssetPrice(address underlyingToken) external view returns (uint256);\n    function getAssetPrice8(address underlyingToken) external view returns (uint256);\n    function getUserAccountData(address user) external view returns (uint256 totalCollateralUsd, uint256 totalDebtUsd);\n}\n\n/**\n * @title KapanViewRouter\n * @notice Unified read-only router for querying position data across lending protocols\n * @dev Aggregates gateway view contracts to provide protocol-agnostic LTV queries for ADL\n *\n * Supported protocols:\n *   - \"aave-v3\": Aave V3 (context: empty)\n *   - \"compound-v3\": Compound V3 (context: abi.encode(baseToken address))\n *   - \"morpho-blue\": Morpho Blue (context: abi.encode(MarketParams))\n *   - \"euler-v2\": Euler V2 (context: abi.encode(vault address, subAccountIndex uint8))\n *   - \"venus\": Venus (context: empty)\n */\ncontract KapanViewRouter {\n    // ============ Errors ============\n\n    error UnsupportedProtocol(string protocolName);\n    error UnsupportedProtocolId(bytes4 protocolId);\n    error GatewayNotSet(string protocolName);\n    error ZeroAddress();\n\n    // ============ Events ============\n\n    event GatewayUpdated(string indexed protocolName, address gateway);\n\n    // ============ Constants ============\n\n    /// @notice Protocol identifiers (bytes4 for unified interface)\n    bytes4 public constant AAVE_V3 = bytes4(keccak256(\"aave-v3\"));\n    bytes4 public constant COMPOUND_V3 = bytes4(keccak256(\"compound-v3\"));\n    bytes4 public constant MORPHO_BLUE = bytes4(keccak256(\"morpho-blue\"));\n    bytes4 public constant EULER_V2 = bytes4(keccak256(\"euler-v2\"));\n    bytes4 public constant VENUS = bytes4(keccak256(\"venus\"));\n\n    // ============ State ============\n\n    /// @notice Owner who can update gateway addresses\n    address public owner;\n\n    /// @notice Protocol name => gateway view address (consistent with KapanRouter)\n    mapping(string => address) public gateways;\n\n    // ============ Modifiers ============\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(address _owner) {\n        if (_owner == address(0)) revert ZeroAddress();\n        owner = _owner;\n    }\n\n    // ============ Admin ============\n\n    /// @notice Set or update a gateway view address\n    /// @param protocolName Protocol name (e.g., \"aave-v3\", \"morpho-blue\")\n    /// @param gateway Gateway view contract address\n    function setGateway(string calldata protocolName, address gateway) external onlyOwner {\n        if (gateway == address(0)) revert ZeroAddress();\n        gateways[protocolName] = gateway;\n        emit GatewayUpdated(protocolName, gateway);\n    }\n\n    /// @notice Batch set multiple gateways\n    /// @param protocolNames Array of protocol names\n    /// @param gatewayAddresses Array of gateway addresses\n    function setGateways(string[] calldata protocolNames, address[] calldata gatewayAddresses) external onlyOwner {\n        require(protocolNames.length == gatewayAddresses.length, \"Length mismatch\");\n        for (uint256 i = 0; i < protocolNames.length; i++) {\n            if (gatewayAddresses[i] == address(0)) revert ZeroAddress();\n            gateways[protocolNames[i]] = gatewayAddresses[i];\n            emit GatewayUpdated(protocolNames[i], gatewayAddresses[i]);\n        }\n    }\n\n    /// @notice Transfer ownership\n    /// @param newOwner New owner address\n    function transferOwnership(address newOwner) external onlyOwner {\n        if (newOwner == address(0)) revert ZeroAddress();\n        owner = newOwner;\n    }\n\n    // ============ LTV Queries ============\n\n    /// @notice Get current LTV for Aave V3\n    /// @param user The user's address\n    /// @return ltvBps Current LTV in basis points\n    function getAaveLtvBps(address user) external view returns (uint256 ltvBps) {\n        address gateway = gateways[\"aave-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"aave-v3\");\n        return IAaveGatewayView(gateway).getCurrentLtvBps(address(0), user);\n    }\n\n    /// @notice Get liquidation LTV for Aave V3\n    function getAaveLiquidationLtvBps(address user) external view returns (uint256) {\n        address gateway = gateways[\"aave-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"aave-v3\");\n        return IAaveGatewayView(gateway).getLiquidationLtvBps(address(0), user);\n    }\n\n    /// @notice Get current LTV for Compound V3\n    /// @param baseToken The base token of the Comet market (e.g., USDC)\n    /// @param user The user's address\n    function getCompoundLtvBps(address baseToken, address user) external view returns (uint256) {\n        address gateway = gateways[\"compound-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"compound-v3\");\n        return ICompoundGatewayView(gateway).getCurrentLtvBps(baseToken, user);\n    }\n\n    /// @notice Get liquidation LTV for Compound V3\n    function getCompoundLiquidationLtvBps(address baseToken, address user) external view returns (uint256) {\n        address gateway = gateways[\"compound-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"compound-v3\");\n        return ICompoundGatewayView(gateway).getLiquidationLtvBps(baseToken, user);\n    }\n\n    /// @notice Get current LTV for Morpho Blue\n    /// @param params The Morpho market parameters\n    /// @param user The user's address\n    function getMorphoLtvBps(MarketParams calldata params, address user) external view returns (uint256) {\n        address gateway = gateways[\"morpho-blue\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"morpho-blue\");\n        return IMorphoBlueGatewayView(gateway).getCurrentLtvBps(params, user);\n    }\n\n    /// @notice Get liquidation LTV for Morpho Blue\n    function getMorphoLiquidationLtvBps(MarketParams calldata params) external view returns (uint256) {\n        address gateway = gateways[\"morpho-blue\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"morpho-blue\");\n        return IMorphoBlueGatewayView(gateway).getLiquidationLtvBps(params);\n    }\n\n    /// @notice Get current LTV for Euler V2\n    /// @param vault The borrow vault address\n    /// @param user The user's address\n    /// @param subAccountIndex The sub-account index (0-255)\n    function getEulerLtvBps(address vault, address user, uint8 subAccountIndex) external view returns (uint256) {\n        address gateway = gateways[\"euler-v2\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"euler-v2\");\n        return IEulerGatewayView(gateway).getCurrentLtvBps(vault, user, subAccountIndex);\n    }\n\n    /// @notice Get liquidation LTV for Euler V2\n    function getEulerLiquidationLtvBps(address vault) external view returns (uint256) {\n        address gateway = gateways[\"euler-v2\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"euler-v2\");\n        return IEulerGatewayView(gateway).getLiquidationLtvBps(vault);\n    }\n\n    /// @notice Get current LTV for Venus\n    /// @param user The user's address\n    function getVenusLtvBps(address user) external view returns (uint256) {\n        address gateway = gateways[\"venus\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"venus\");\n        return IVenusGatewayView(gateway).getCurrentLtvBps(address(0), user);\n    }\n\n    /// @notice Get liquidation LTV for Venus\n    function getVenusLiquidationLtvBps(address user) external view returns (uint256) {\n        address gateway = gateways[\"venus\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"venus\");\n        return IVenusGatewayView(gateway).getLiquidationLtvBps(address(0), user);\n    }\n\n    // ============ Risk Assessment ============\n\n    /// @notice Check if Aave position is at liquidation risk\n    /// @param user The user's address\n    /// @param bufferBps Safety buffer in basis points (e.g., 500 = 5%)\n    /// @return atRisk True if current LTV + buffer >= liquidation LTV\n    function isAaveAtRisk(address user, uint256 bufferBps) external view returns (bool atRisk) {\n        uint256 currentLtv = this.getAaveLtvBps(user);\n        uint256 liquidationLtv = this.getAaveLiquidationLtvBps(user);\n        if (currentLtv == 0 || liquidationLtv == 0) return false;\n        return currentLtv + bufferBps >= liquidationLtv;\n    }\n\n    /// @notice Check if Compound position is at liquidation risk\n    function isCompoundAtRisk(address baseToken, address user, uint256 bufferBps) external view returns (bool) {\n        uint256 currentLtv = this.getCompoundLtvBps(baseToken, user);\n        uint256 liquidationLtv = this.getCompoundLiquidationLtvBps(baseToken, user);\n        if (currentLtv == 0 || liquidationLtv == 0) return false;\n        return currentLtv + bufferBps >= liquidationLtv;\n    }\n\n    /// @notice Check if Morpho position is at liquidation risk\n    function isMorphoAtRisk(\n        MarketParams calldata params,\n        address user,\n        uint256 bufferBps\n    ) external view returns (bool) {\n        uint256 currentLtv = this.getMorphoLtvBps(params, user);\n        uint256 liquidationLtv = this.getMorphoLiquidationLtvBps(params);\n        if (currentLtv == 0 || liquidationLtv == 0) return false;\n        return currentLtv + bufferBps >= liquidationLtv;\n    }\n\n    // ============ Price Queries (for ADL floor pricing) ============\n    // All prices normalized to 8 decimals USD\n\n    /// @notice Get asset price via Aave oracle (8 decimals)\n    /// @param token The asset address\n    /// @return price Price in 8 decimals USD\n    function getAavePrice(address token) external view returns (uint256) {\n        address gateway = gateways[\"aave-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"aave-v3\");\n        return IAaveGatewayView(gateway).getAssetPrice(token);\n    }\n\n    /// @notice Get multiple asset prices via Aave oracle\n    function getAavePrices(address[] calldata tokens) external view returns (uint256[] memory) {\n        address gateway = gateways[\"aave-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"aave-v3\");\n        return IAaveGatewayView(gateway).getAssetPrices(tokens);\n    }\n\n    /// @notice Get asset price via Compound (8 decimals)\n    /// @param baseToken The Comet base token (e.g., USDC)\n    /// @param asset The asset to price (collateral or base token)\n    /// @return price Price in 8 decimals USD\n    function getCompoundPrice(address baseToken, address asset) external view returns (uint256) {\n        address gateway = gateways[\"compound-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"compound-v3\");\n        // If pricing the base token, use getPrice; otherwise use getCollateralPrice\n        if (asset == baseToken) {\n            return ICompoundGatewayView(gateway).getPrice(asset);\n        }\n        return ICompoundGatewayView(gateway).getCollateralPrice(baseToken, asset);\n    }\n\n    /// @notice Get Morpho oracle price (36 decimals, collateral/loan ratio)\n    /// @dev This is NOT a USD price - it's the exchange rate from collateral to loan token\n    /// @param params The Morpho market parameters\n    /// @return price Price ratio with 36 decimals\n    function getMorphoOraclePrice(MarketParams calldata params) external view returns (uint256) {\n        address gateway = gateways[\"morpho-blue\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"morpho-blue\");\n        return IMorphoBlueGatewayView(gateway).getOraclePrice(params);\n    }\n\n    /// @notice Get asset price via Venus oracle (8 decimals normalized)\n    /// @param underlyingToken The underlying asset address\n    /// @return price Price in 8 decimals USD\n    function getVenusPrice(address underlyingToken) external view returns (uint256) {\n        address gateway = gateways[\"venus\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"venus\");\n        return IVenusGatewayView(gateway).getAssetPrice8(underlyingToken);\n    }\n\n    /// @notice Get asset price via Euler oracle (in vault's unit of account)\n    /// @param vault The Euler vault address (determines oracle)\n    /// @param token The token to price\n    /// @return price Price in unit of account decimals\n    function getEulerPrice(address vault, address token) external view returns (uint256) {\n        address gateway = gateways[\"euler-v2\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"euler-v2\");\n        return IEulerGatewayView(gateway).getAssetPrice(vault, token);\n    }\n\n    /// @notice Get exchange rate for Euler position (collateral → debt)\n    /// @dev Returns 18-decimal exchange rate ready for calculateMinBuyFromRate()\n    /// @param borrowVault The borrow vault (debt side)\n    /// @param collateralVault The collateral vault\n    /// @return rate18 Exchange rate with 18 decimals\n    function getEulerExchangeRate(address borrowVault, address collateralVault) external view returns (uint256) {\n        address gateway = gateways[\"euler-v2\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"euler-v2\");\n        return IEulerGatewayView(gateway).getCollateralToDebtRate(borrowVault, collateralVault);\n    }\n\n    // ============ Position Value Queries (for ADL) ============\n    // All values in 8 decimals USD\n\n    /// @notice Get Aave user account data (collateral and debt in USD)\n    /// @param user The user address\n    /// @return totalCollateralBase Total collateral in 8 decimals USD\n    /// @return totalDebtBase Total debt in 8 decimals USD\n    /// @return availableBorrowsBase Available borrows in 8 decimals USD\n    /// @return currentLiquidationThreshold Liquidation threshold in basis points\n    /// @return ltv Loan-to-value ratio in basis points\n    /// @return healthFactor Health factor (1e18 scale)\n    function getAaveUserAccountData(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        )\n    {\n        address gateway = gateways[\"aave-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"aave-v3\");\n        return IAaveGatewayView(gateway).getUserAccountData(user);\n    }\n\n    /// @notice Get Compound position value (collateral and debt in USD)\n    /// @param baseToken The Comet base token (e.g., USDC)\n    /// @param user The user address\n    /// @return collateralValueUsd Total collateral in 8 decimals USD\n    /// @return debtValueUsd Total debt in 8 decimals USD\n    function getCompoundPositionValue(\n        address baseToken,\n        address user\n    ) external view returns (uint256 collateralValueUsd, uint256 debtValueUsd) {\n        address gateway = gateways[\"compound-v3\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"compound-v3\");\n        return ICompoundGatewayView(gateway).getPositionValue(baseToken, user);\n    }\n\n    /// @notice Get Morpho position value (collateral and debt in USD)\n    /// @param params The Morpho market parameters\n    /// @param user The user address\n    /// @return collateralValueUsd Total collateral in 8 decimals USD\n    /// @return debtValueUsd Total debt in 8 decimals USD\n    function getMorphoPositionValue(\n        MarketParams calldata params,\n        address user\n    ) external view returns (uint256 collateralValueUsd, uint256 debtValueUsd) {\n        address gateway = gateways[\"morpho-blue\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"morpho-blue\");\n        return IMorphoBlueGatewayView(gateway).getPositionValue(params, user);\n    }\n\n    /// @notice Get Venus user account data (collateral and debt in USD)\n    /// @param user The user address\n    /// @return totalCollateralUsd Total collateral in 8 decimals USD\n    /// @return totalDebtUsd Total debt in 8 decimals USD\n    function getVenusUserAccountData(\n        address user\n    ) external view returns (uint256 totalCollateralUsd, uint256 totalDebtUsd) {\n        address gateway = gateways[\"venus\"];\n        if (gateway == address(0)) revert GatewayNotSet(\"venus\");\n        return IVenusGatewayView(gateway).getUserAccountData(user);\n    }\n\n    // ============ ADL Floor Price Calculation ============\n\n    /// @notice Calculate minimum buy amount using exchange rate\n    /// @dev Exchange rate = how many buyTokens per sellToken, scaled by 1e18\n    /// @param sellAmount Amount of sellToken (in sellToken decimals)\n    /// @param maxSlippageBps Maximum slippage in basis points (e.g., 100 = 1%)\n    /// @param exchangeRate18 Exchange rate with 18 decimals (sellToken → buyToken)\n    /// @param sellDecimals Decimals of sell token\n    /// @param buyDecimals Decimals of buy token\n    /// @return minBuyAmount Minimum acceptable buy amount\n    function calculateMinBuyFromRate(\n        uint256 sellAmount,\n        uint256 maxSlippageBps,\n        uint256 exchangeRate18,\n        uint8 sellDecimals,\n        uint8 buyDecimals\n    ) external pure returns (uint256 minBuyAmount) {\n        if (exchangeRate18 == 0) return 0;\n\n        // buyAmount = sellAmount * exchangeRate / 1e18\n        // Then adjust for decimal difference between tokens\n\n        // Step 1: Apply exchange rate (result has sellDecimals precision)\n        uint256 rawBuyAmount = (sellAmount * exchangeRate18) / 1e18;\n\n        // Step 2: Adjust for decimal difference\n        if (buyDecimals >= sellDecimals) {\n            minBuyAmount = rawBuyAmount * (10 ** (buyDecimals - sellDecimals));\n        } else {\n            minBuyAmount = rawBuyAmount / (10 ** (sellDecimals - buyDecimals));\n        }\n\n        // Step 3: Apply slippage tolerance\n        minBuyAmount = (minBuyAmount * (10000 - maxSlippageBps)) / 10000;\n    }\n\n    /// @notice Convert two USD prices (same decimals) to an 18-decimal exchange rate\n    /// @dev exchangeRate18 = sellPriceUsd * 1e18 / buyPriceUsd\n    /// @param sellPriceUsd USD price of sell token (any decimals, but same as buyPriceUsd)\n    /// @param buyPriceUsd USD price of buy token (any decimals, but same as sellPriceUsd)\n    /// @return exchangeRate18 Exchange rate with 18 decimals\n    function usdPricesToExchangeRate(\n        uint256 sellPriceUsd,\n        uint256 buyPriceUsd\n    ) external pure returns (uint256 exchangeRate18) {\n        if (buyPriceUsd == 0) return 0;\n        return (sellPriceUsd * 1e18) / buyPriceUsd;\n    }\n\n    /// @notice Calculate minimum buy amount for ADL order with slippage protection\n    /// @dev Convenience function that takes USD prices and converts to exchange rate internally\n    /// @param sellAmount Amount of sellToken\n    /// @param maxSlippageBps Maximum slippage in basis points (e.g., 100 = 1%)\n    /// @param sellPriceUsd Price of sellToken (any decimals)\n    /// @param buyPriceUsd Price of buyToken (same decimals as sellPriceUsd)\n    /// @param sellDecimals Decimals of sell token\n    /// @param buyDecimals Decimals of buy token\n    /// @return minBuyAmount Minimum acceptable buy amount\n    function calculateMinBuyAmount(\n        uint256 sellAmount,\n        uint256 maxSlippageBps,\n        uint256 sellPriceUsd,\n        uint256 buyPriceUsd,\n        uint8 sellDecimals,\n        uint8 buyDecimals\n    ) external view returns (uint256 minBuyAmount) {\n        if (sellPriceUsd == 0 || buyPriceUsd == 0) return 0;\n\n        // Convert USD prices to exchange rate\n        uint256 exchangeRate18 = (sellPriceUsd * 1e18) / buyPriceUsd;\n\n        // Use the exchange rate calculation\n        return this.calculateMinBuyFromRate(sellAmount, maxSlippageBps, exchangeRate18, sellDecimals, buyDecimals);\n    }\n\n    /// @notice Calculate minimum buy amount for Morpho ADL orders\n    /// @dev Morpho oracles return the exchange rate scaled by 1e36\n    ///      Formula: loanAmount = collateralAmount * price / 1e36\n    ///      The oracle price already accounts for token decimals\n    /// @param sellAmount Amount of collateral to sell (in collateral token decimals)\n    /// @param maxSlippageBps Maximum slippage in basis points\n    /// @param morphoOraclePrice Price from Morpho oracle (36 decimals scale)\n    /// @return minBuyAmount Minimum acceptable loan tokens to receive\n    function calculateMorphoMinBuyAmount(\n        uint256 sellAmount,\n        uint256 maxSlippageBps,\n        uint256 morphoOraclePrice\n    ) external pure returns (uint256 minBuyAmount) {\n        if (morphoOraclePrice == 0) return 0;\n\n        // Morpho oracle: loanAmount = collateralAmount * price / ORACLE_PRICE_SCALE\n        // The oracle price already incorporates the decimal difference between tokens\n        // ORACLE_PRICE_SCALE = 1e36\n\n        minBuyAmount = (sellAmount * morphoOraclePrice) / 1e36;\n\n        // Apply slippage tolerance\n        minBuyAmount = (minBuyAmount * (10000 - maxSlippageBps)) / 10000;\n    }\n\n    // ============ Unified Interface (Protocol-Agnostic) ============\n    // These functions allow callers to interact with any protocol using a bytes4 protocolId\n    // and protocol-specific context data, without needing to know protocol internals.\n\n    /// @notice Get the protocol name for a protocol ID\n    /// @param protocolId The bytes4 protocol identifier\n    /// @return protocolName The string protocol name for gateway lookup\n    function _getProtocolName(bytes4 protocolId) internal pure returns (string memory protocolName) {\n        if (protocolId == AAVE_V3) return \"aave-v3\";\n        if (protocolId == COMPOUND_V3) return \"compound-v3\";\n        if (protocolId == MORPHO_BLUE) return \"morpho-blue\";\n        if (protocolId == EULER_V2) return \"euler-v2\";\n        if (protocolId == VENUS) return \"venus\";\n        revert UnsupportedProtocolId(protocolId);\n    }\n\n    /// @notice Get current LTV for any protocol (unified interface)\n    /// @param protocolId Protocol identifier (AAVE_V3, COMPOUND_V3, etc.)\n    /// @param user User address\n    /// @param context Protocol-specific context:\n    ///   - AAVE_V3: empty bytes\n    ///   - COMPOUND_V3: abi.encode(baseToken address)\n    ///   - MORPHO_BLUE: abi.encode(MarketParams)\n    ///   - EULER_V2: abi.encode(vault address, subAccountIndex uint8)\n    ///   - VENUS: empty bytes\n    /// @return ltvBps Current LTV in basis points\n    function getCurrentLtv(\n        bytes4 protocolId,\n        address user,\n        bytes calldata context\n    ) external view returns (uint256 ltvBps) {\n        string memory protocolName = _getProtocolName(protocolId);\n        address gateway = gateways[protocolName];\n        if (gateway == address(0)) revert GatewayNotSet(protocolName);\n\n        if (protocolId == AAVE_V3) {\n            return IAaveGatewayView(gateway).getCurrentLtvBps(address(0), user);\n        }\n        if (protocolId == COMPOUND_V3) {\n            address baseToken = abi.decode(context, (address));\n            return ICompoundGatewayView(gateway).getCurrentLtvBps(baseToken, user);\n        }\n        if (protocolId == MORPHO_BLUE) {\n            MarketParams memory params = abi.decode(context, (MarketParams));\n            return IMorphoBlueGatewayView(gateway).getCurrentLtvBps(params, user);\n        }\n        if (protocolId == EULER_V2) {\n            (address vault, uint8 subAccountIndex) = abi.decode(context, (address, uint8));\n            return IEulerGatewayView(gateway).getCurrentLtvBps(vault, user, subAccountIndex);\n        }\n        if (protocolId == VENUS) {\n            return IVenusGatewayView(gateway).getCurrentLtvBps(address(0), user);\n        }\n\n        revert UnsupportedProtocolId(protocolId);\n    }\n\n    /// @notice Get position value for any protocol (unified interface)\n    /// @param protocolId Protocol identifier\n    /// @param user User address\n    /// @param context Protocol-specific context (see getCurrentLtv)\n    /// @return collateralValueUsd Total collateral in 8 decimals USD\n    /// @return debtValueUsd Total debt in 8 decimals USD\n    function getPositionValue(\n        bytes4 protocolId,\n        address user,\n        bytes calldata context\n    ) external view returns (uint256 collateralValueUsd, uint256 debtValueUsd) {\n        string memory protocolName = _getProtocolName(protocolId);\n        address gateway = gateways[protocolName];\n        if (gateway == address(0)) revert GatewayNotSet(protocolName);\n\n        if (protocolId == AAVE_V3) {\n            (uint256 totalCollateral, uint256 totalDebt, , , , ) = IAaveGatewayView(gateway).getUserAccountData(user);\n            return (totalCollateral, totalDebt);\n        }\n        if (protocolId == COMPOUND_V3) {\n            address baseToken = abi.decode(context, (address));\n            return ICompoundGatewayView(gateway).getPositionValue(baseToken, user);\n        }\n        if (protocolId == MORPHO_BLUE) {\n            MarketParams memory params = abi.decode(context, (MarketParams));\n            return IMorphoBlueGatewayView(gateway).getPositionValue(params, user);\n        }\n        if (protocolId == VENUS) {\n            return IVenusGatewayView(gateway).getUserAccountData(user);\n        }\n        if (protocolId == EULER_V2) {\n            (address vault, uint8 subAccountIndex) = abi.decode(context, (address, uint8));\n            return IEulerGatewayView(gateway).getUserAccountData(vault, user, subAccountIndex);\n        }\n\n        revert UnsupportedProtocolId(protocolId);\n    }\n\n    /// @notice Get collateral price for any protocol (unified interface)\n    /// @param protocolId Protocol identifier\n    /// @param collateralToken Collateral token address\n    /// @param context Protocol-specific context (see getCurrentLtv)\n    /// @return price Price in 8 decimals USD (or 1e8 for protocols using exchange rates)\n    function getCollateralPrice(\n        bytes4 protocolId,\n        address collateralToken,\n        bytes calldata context\n    ) external view returns (uint256 price) {\n        string memory protocolName = _getProtocolName(protocolId);\n        address gateway = gateways[protocolName];\n        if (gateway == address(0)) revert GatewayNotSet(protocolName);\n\n        if (protocolId == AAVE_V3) {\n            return IAaveGatewayView(gateway).getAssetPrice(collateralToken);\n        }\n        if (protocolId == COMPOUND_V3) {\n            address baseToken = abi.decode(context, (address));\n            if (collateralToken == baseToken) {\n                return ICompoundGatewayView(gateway).getPrice(collateralToken);\n            }\n            return ICompoundGatewayView(gateway).getCollateralPrice(baseToken, collateralToken);\n        }\n        if (protocolId == VENUS) {\n            return IVenusGatewayView(gateway).getAssetPrice8(collateralToken);\n        }\n        if (protocolId == MORPHO_BLUE) {\n            // For Morpho, derive collateral price from the oracle\n            // Oracle returns collateral/loan exchange rate scaled by 10^(36 + loanDecimals - collateralDecimals)\n            // We want price in 8 decimals, so divide by 10^(36 + loanDecimals - collateralDecimals - 8)\n            // = 10^(28 + loanDecimals - collateralDecimals)\n            MarketParams memory params = abi.decode(context, (MarketParams));\n            uint256 oraclePrice = IMorphoBlueGatewayView(gateway).getOraclePrice(params);\n            if (oraclePrice > 0) {\n                uint8 loanDecimals = _getDecimals(params.loanToken);\n                uint8 collateralDecimals = _getDecimals(params.collateralToken);\n                // exponent = 28 + loanDecimals - collateralDecimals\n                // Examples:\n                //   WBTC(8)/USDC(6):  28 + 6 - 8  = 26\n                //   ETH(18)/USDC(6):  28 + 6 - 18 = 16\n                //   USDC(6)/ETH(18):  28 + 18 - 6 = 40\n                //   USDC(6)/USDT(6):  28 + 6 - 6  = 28\n                int16 exponent = 28 + int16(uint16(loanDecimals)) - int16(uint16(collateralDecimals));\n                if (exponent >= 0) {\n                    return oraclePrice / (10 ** uint16(exponent));\n                } else {\n                    // Negative exponent means multiply instead of divide\n                    // This would only happen if collateralDecimals > 28 + loanDecimals\n                    // (e.g., a token with 35+ decimals, which doesn't exist in practice)\n                    return oraclePrice * (10 ** uint16(-exponent));\n                }\n            }\n        }\n        // Euler and fallback: return placeholder (caller should handle)\n        return 1e8;\n    }\n\n    /// @notice Get debt price for any protocol (unified interface)\n    /// @param protocolId Protocol identifier\n    /// @param debtToken Debt token address\n    /// @param context Protocol-specific context (see getCurrentLtv)\n    /// @return price Price in 8 decimals USD (or 1e8 for protocols using exchange rates)\n    function getDebtPrice(\n        bytes4 protocolId,\n        address debtToken,\n        bytes calldata context\n    ) external view returns (uint256 price) {\n        string memory protocolName = _getProtocolName(protocolId);\n        address gateway = gateways[protocolName];\n        if (gateway == address(0)) revert GatewayNotSet(protocolName);\n\n        if (protocolId == AAVE_V3) {\n            return IAaveGatewayView(gateway).getAssetPrice(debtToken);\n        }\n        if (protocolId == COMPOUND_V3) {\n            address baseToken = abi.decode(context, (address));\n            if (debtToken == baseToken) {\n                return ICompoundGatewayView(gateway).getPrice(debtToken);\n            }\n            return ICompoundGatewayView(gateway).getCollateralPrice(baseToken, debtToken);\n        }\n        if (protocolId == VENUS) {\n            return IVenusGatewayView(gateway).getAssetPrice8(debtToken);\n        }\n        if (protocolId == MORPHO_BLUE) {\n            // For Morpho, the loan token is the unit of account, so its price is 1.0\n            // This is consistent with how getPositionValue calculates debt in \"loan token terms\"\n            return 1e8;\n        }\n        // Euler and fallback: return placeholder (caller should handle)\n        return 1e8;\n    }\n\n    /// @notice Calculate minimum buy amount with slippage for any protocol (unified interface)\n    /// @param protocolId Protocol identifier\n    /// @param sellAmount Amount to sell\n    /// @param maxSlippageBps Maximum slippage in basis points\n    /// @param collateralToken Collateral token\n    /// @param debtToken Debt token\n    /// @param collateralDecimals Collateral token decimals\n    /// @param debtDecimals Debt token decimals\n    /// @param context Protocol-specific context (see getCurrentLtv)\n    /// @return minBuyAmount Minimum acceptable buy amount\n    function calculateMinBuy(\n        bytes4 protocolId,\n        uint256 sellAmount,\n        uint256 maxSlippageBps,\n        address collateralToken,\n        address debtToken,\n        uint8 collateralDecimals,\n        uint8 debtDecimals,\n        bytes calldata context\n    ) external view returns (uint256 minBuyAmount) {\n        string memory protocolName = _getProtocolName(protocolId);\n        address gateway = gateways[protocolName];\n        if (gateway == address(0)) revert GatewayNotSet(protocolName);\n\n        if (protocolId == MORPHO_BLUE) {\n            // For Morpho, use the Morpho oracle which gives collateral/loan exchange rate\n            // This is consistent with how getPositionValue and getCollateralPrice work\n            MarketParams memory params = abi.decode(context, (MarketParams));\n            uint256 morphoPrice = IMorphoBlueGatewayView(gateway).getOraclePrice(params);\n            return _calculateMorphoMinBuy(sellAmount, maxSlippageBps, morphoPrice);\n        }\n\n        if (protocolId == EULER_V2) {\n            // Euler uses 18-decimal exchange rate\n            (address borrowVault, ) = abi.decode(context, (address, uint8));\n            uint256 eulerExchangeRate = IEulerGatewayView(gateway).getCollateralToDebtRate(\n                borrowVault,\n                collateralToken\n            );\n            return\n                _calculateMinBuyFromRate(\n                    sellAmount,\n                    maxSlippageBps,\n                    eulerExchangeRate,\n                    collateralDecimals,\n                    debtDecimals\n                );\n        }\n\n        // For Aave, Compound, Venus - use USD prices\n        uint256 collateralPrice = this.getCollateralPrice(protocolId, collateralToken, context);\n        uint256 debtPrice = this.getDebtPrice(protocolId, debtToken, context);\n\n        if (collateralPrice == 0 || debtPrice == 0) {\n            return 0;\n        }\n\n        uint256 exchangeRate18 = (collateralPrice * 1e18) / debtPrice;\n        return _calculateMinBuyFromRate(sellAmount, maxSlippageBps, exchangeRate18, collateralDecimals, debtDecimals);\n    }\n\n    /// @dev Internal helper for calculating min buy from exchange rate\n    function _calculateMinBuyFromRate(\n        uint256 sellAmount,\n        uint256 maxSlippageBps,\n        uint256 exchangeRate18,\n        uint8 sellDecimals,\n        uint8 buyDecimals\n    ) internal pure returns (uint256 minBuyAmount) {\n        if (exchangeRate18 == 0) return 0;\n\n        // buyAmount = sellAmount * exchangeRate / 1e18\n        uint256 rawBuyAmount = (sellAmount * exchangeRate18) / 1e18;\n\n        // Adjust for decimal difference\n        if (buyDecimals >= sellDecimals) {\n            minBuyAmount = rawBuyAmount * (10 ** (buyDecimals - sellDecimals));\n        } else {\n            minBuyAmount = rawBuyAmount / (10 ** (sellDecimals - buyDecimals));\n        }\n\n        // Apply slippage tolerance\n        minBuyAmount = (minBuyAmount * (10000 - maxSlippageBps)) / 10000;\n    }\n\n    /// @dev Internal helper for calculating min buy from Morpho oracle price\n    function _calculateMorphoMinBuy(\n        uint256 sellAmount,\n        uint256 maxSlippageBps,\n        uint256 morphoOraclePrice\n    ) internal pure returns (uint256 minBuyAmount) {\n        if (morphoOraclePrice == 0) return 0;\n\n        // Morpho oracle: loanAmount = collateralAmount * price / 1e36\n        minBuyAmount = (sellAmount * morphoOraclePrice) / 1e36;\n\n        // Apply slippage tolerance\n        minBuyAmount = (minBuyAmount * (10000 - maxSlippageBps)) / 10000;\n    }\n\n    /// @dev Get token decimals with fallback to 18\n    function _getDecimals(address token) internal view returns (uint8) {\n        try IERC20Metadata(token).decimals() returns (uint8 d) {\n            return d;\n        } catch {\n            return 18;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}