{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/v2/gateways/morpho/MorphoBlueGatewayView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport { IMorphoBlue, MarketParams, Market, Position, MorphoLib } from \"../../interfaces/morpho/IMorphoBlue.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @notice Interface for Morpho Blue oracles\n/// @dev Returns price as collateralToken/loanToken with 36 decimals of precision\ninterface IMorphoOracle {\n    function price() external view returns (uint256);\n}\n\n/// @notice Interface for Morpho Blue Interest Rate Models\ninterface IMorphoIrm {\n    /// @notice Returns the borrow rate per second (scaled to 1e18)\n    function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256);\n}\n\n/**\n * @title MorphoBlueGatewayView\n * @notice View-only gateway for querying Morpho Blue positions and market data\n * @dev Provides utility functions for reading user balances, market state, and risk parameters\n *      Designed for frontend parity with Aave/Compound view gateways\n */\ncontract MorphoBlueGatewayView is Ownable {\n    using MorphoLib for MarketParams;\n\n    /// @notice The Morpho Blue singleton contract\n    IMorphoBlue public immutable morpho;\n\n    /// @notice Registry of known markets for enumeration\n    bytes32[] private _registeredMarketIds;\n    mapping(bytes32 => MarketParams) private _marketParams;\n    mapping(bytes32 => bool) private _isRegistered;\n\n    /// @notice Struct for returning comprehensive market info (similar to Aave's TokenInfo)\n    struct MarketInfo {\n        bytes32 marketId;\n        address loanToken;\n        address collateralToken;\n        string loanSymbol;\n        string collateralSymbol;\n        uint8 loanDecimals;\n        uint8 collateralDecimals;\n        uint256 lltv;                  // Max LTV in 18 decimals (e.g., 0.86e18 = 86%)\n        uint256 totalSupplyAssets;     // Total supplied to market\n        uint256 totalBorrowAssets;     // Total borrowed from market\n        uint256 utilizationRate;       // Utilization in 18 decimals\n        uint256 borrowRate;            // Borrow APR in 18 decimals (per second * seconds per year)\n        uint256 supplyRate;            // Supply APR in 18 decimals\n        uint256 oraclePrice;           // Oracle price (collateral/loan, 36 decimals)\n    }\n\n    /// @notice Struct for user position in a market\n    struct UserPosition {\n        bytes32 marketId;\n        address loanToken;\n        address collateralToken;\n        uint256 collateralBalance;     // Collateral in underlying units\n        uint256 borrowBalance;         // Borrow debt in underlying units\n        uint256 supplyBalance;         // Supply balance (lender side) in underlying units\n        uint256 collateralValueUsd;    // Collateral value (scaled to loan token decimals for comparison)\n        uint256 borrowValueUsd;        // Borrow value (in loan token units)\n        uint256 currentLtv;            // Current LTV in 18 decimals\n        uint256 maxLtv;                // Max LTV (LLTV) in 18 decimals\n        uint256 healthFactor;          // Health factor in 18 decimals (1e18 = 1.0)\n        bool isHealthy;                // Whether position is above liquidation threshold\n    }\n\n    /// @notice Reserve config data (similar to Aave's ReserveConfigData)\n    struct MarketConfigData {\n        bytes32 marketId;\n        address loanToken;\n        address collateralToken;\n        uint256 lltv;                  // Max LTV in 18 decimals\n        uint256 oraclePrice;           // Oracle price\n        uint8 loanDecimals;\n        uint8 collateralDecimals;\n        bool isActive;                 // Whether market has any supply\n    }\n\n    event MarketRegistered(bytes32 indexed marketId, address loanToken, address collateralToken);\n    event MarketRemoved(bytes32 indexed marketId);\n\n    constructor(address morpho_, address owner_) Ownable(owner_) {\n        require(morpho_ != address(0), \"MorphoBlue: zero address\");\n        morpho = IMorphoBlue(morpho_);\n    }\n\n    // ============ Market Registry ============\n\n    /// @notice Register a market for enumeration\n    function registerMarket(MarketParams calldata params) external onlyOwner {\n        bytes32 marketId = params.id();\n        require(!_isRegistered[marketId], \"MorphoBlue: already registered\");\n        \n        _registeredMarketIds.push(marketId);\n        _marketParams[marketId] = params;\n        _isRegistered[marketId] = true;\n        \n        emit MarketRegistered(marketId, params.loanToken, params.collateralToken);\n    }\n\n    /// @notice Register multiple markets at once\n    function registerMarkets(MarketParams[] calldata paramsList) external onlyOwner {\n        for (uint256 i = 0; i < paramsList.length; i++) {\n            bytes32 marketId = paramsList[i].id();\n            if (!_isRegistered[marketId]) {\n                _registeredMarketIds.push(marketId);\n                _marketParams[marketId] = paramsList[i];\n                _isRegistered[marketId] = true;\n                emit MarketRegistered(marketId, paramsList[i].loanToken, paramsList[i].collateralToken);\n            }\n        }\n    }\n\n    /// @notice Get all registered market IDs\n    function getRegisteredMarketIds() external view returns (bytes32[] memory) {\n        return _registeredMarketIds;\n    }\n\n    /// @notice Get market params by ID\n    function getMarketParams(bytes32 marketId) external view returns (MarketParams memory) {\n        require(_isRegistered[marketId], \"MorphoBlue: not registered\");\n        return _marketParams[marketId];\n    }\n\n    /// @notice Check if a market is registered\n    function isMarketRegistered(bytes32 marketId) external view returns (bool) {\n        return _isRegistered[marketId];\n    }\n\n    // ============ Single Market Queries ============\n\n    /// @notice Get user's collateral balance in a market\n    function getCollateralBalance(MarketParams calldata params, address user) external view returns (uint256) {\n        bytes32 marketId = params.id();\n        Position memory pos = morpho.position(marketId, user);\n        return pos.collateral;\n    }\n\n    /// @notice Get user's borrow balance in a market (converts shares to assets)\n    function getBorrowBalance(MarketParams calldata params, address user) external view returns (uint256) {\n        bytes32 marketId = params.id();\n        Position memory pos = morpho.position(marketId, user);\n\n        if (pos.borrowShares == 0) return 0;\n\n        Market memory mkt = morpho.market(marketId);\n        if (mkt.totalBorrowShares == 0) return 0;\n\n        return (uint256(pos.borrowShares) * uint256(mkt.totalBorrowAssets)) / uint256(mkt.totalBorrowShares);\n    }\n\n    /// @notice Get user's supply balance in a market (lender side, converts shares to assets)\n    function getSupplyBalance(MarketParams calldata params, address user) external view returns (uint256) {\n        bytes32 marketId = params.id();\n        Position memory pos = morpho.position(marketId, user);\n\n        if (pos.supplyShares == 0) return 0;\n\n        Market memory mkt = morpho.market(marketId);\n        if (mkt.totalSupplyShares == 0) return 0;\n\n        return (pos.supplyShares * uint256(mkt.totalSupplyAssets)) / uint256(mkt.totalSupplyShares);\n    }\n\n    /// @notice Get market state\n    function getMarketState(\n        MarketParams calldata params\n    ) external view returns (uint256 totalSupplyAssets, uint256 totalBorrowAssets, uint256 utilizationRate) {\n        bytes32 marketId = params.id();\n        Market memory mkt = morpho.market(marketId);\n\n        totalSupplyAssets = mkt.totalSupplyAssets;\n        totalBorrowAssets = mkt.totalBorrowAssets;\n\n        if (totalSupplyAssets > 0) {\n            utilizationRate = (totalBorrowAssets * 1e18) / totalSupplyAssets;\n        }\n    }\n\n    /// @notice Get oracle price for a market\n    /// @dev Returns price as collateral/loan with 36 decimals\n    function getOraclePrice(MarketParams calldata params) external view returns (uint256) {\n        if (params.oracle == address(0)) return 0;\n        try IMorphoOracle(params.oracle).price() returns (uint256 p) {\n            return p;\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice Get borrow rate for a market (per second, scaled to 1e18)\n    function getBorrowRate(MarketParams calldata params) external view returns (uint256) {\n        if (params.irm == address(0)) return 0;\n        \n        bytes32 marketId = params.id();\n        Market memory mkt = morpho.market(marketId);\n        \n        try IMorphoIrm(params.irm).borrowRateView(params, mkt) returns (uint256 rate) {\n            return rate;\n        } catch {\n            return 0;\n        }\n    }\n\n    /// @notice Get borrow APR for a market (annualized, scaled to 1e18)\n    function getBorrowApr(MarketParams calldata params) external view returns (uint256) {\n        uint256 ratePerSecond = this.getBorrowRate(params);\n        // APR = rate per second * seconds per year\n        return ratePerSecond * 365 days;\n    }\n\n    /// @notice Get supply APR for a market (annualized, scaled to 1e18)\n    /// @dev Supply APR = Borrow APR * Utilization * (1 - fee)\n    function getSupplyApr(MarketParams calldata params) external view returns (uint256) {\n        bytes32 marketId = params.id();\n        Market memory mkt = morpho.market(marketId);\n        \n        if (mkt.totalSupplyAssets == 0) return 0;\n        \n        uint256 borrowApr = this.getBorrowApr(params);\n        uint256 utilization = (uint256(mkt.totalBorrowAssets) * 1e18) / uint256(mkt.totalSupplyAssets);\n        uint256 feeRate = mkt.fee; // Fee is in 18 decimals\n        \n        // Supply APR = Borrow APR * Utilization * (1 - fee)\n        return (borrowApr * utilization * (1e18 - feeRate)) / 1e18 / 1e18;\n    }\n\n    // ============ User Position Queries ============\n\n    /// @notice Get user's full position in a market with risk metrics\n    function getPosition(\n        MarketParams calldata params,\n        address user\n    ) external view returns (UserPosition memory pos) {\n        bytes32 marketId = params.id();\n        Position memory rawPos = morpho.position(marketId, user);\n        Market memory mkt = morpho.market(marketId);\n\n        pos.marketId = marketId;\n        pos.loanToken = params.loanToken;\n        pos.collateralToken = params.collateralToken;\n        pos.collateralBalance = rawPos.collateral;\n        pos.maxLtv = params.lltv;\n\n        // Convert shares to assets\n        if (rawPos.borrowShares > 0 && mkt.totalBorrowShares > 0) {\n            pos.borrowBalance = (uint256(rawPos.borrowShares) * uint256(mkt.totalBorrowAssets)) / uint256(mkt.totalBorrowShares);\n        }\n\n        if (rawPos.supplyShares > 0 && mkt.totalSupplyShares > 0) {\n            pos.supplyBalance = (rawPos.supplyShares * uint256(mkt.totalSupplyAssets)) / uint256(mkt.totalSupplyShares);\n        }\n\n        // Calculate LTV and health factor using oracle\n        if (params.oracle != address(0) && pos.collateralBalance > 0) {\n            try IMorphoOracle(params.oracle).price() returns (uint256 oraclePrice) {\n                // Oracle price is collateral/loan with 36 decimals\n                // collateralValue (in loan token) = collateral * oraclePrice / 1e36\n                uint8 collateralDecimals = _getDecimals(params.collateralToken);\n                uint8 loanDecimals = _getDecimals(params.loanToken);\n                \n                // Normalize to loan token decimals\n                // collateralValue = collateral * price / 10^36 * 10^loanDecimals / 10^collateralDecimals\n                uint256 collateralValue = (pos.collateralBalance * oraclePrice) / 1e36;\n                if (collateralDecimals > loanDecimals) {\n                    collateralValue = collateralValue / (10 ** (collateralDecimals - loanDecimals));\n                } else if (loanDecimals > collateralDecimals) {\n                    collateralValue = collateralValue * (10 ** (loanDecimals - collateralDecimals));\n                }\n                \n                pos.collateralValueUsd = collateralValue;\n                pos.borrowValueUsd = pos.borrowBalance;\n\n                if (collateralValue > 0) {\n                    // Current LTV = borrow / collateralValue\n                    pos.currentLtv = (pos.borrowBalance * 1e18) / collateralValue;\n                    \n                    // Health Factor = (collateralValue * LLTV) / borrow\n                    if (pos.borrowBalance > 0) {\n                        pos.healthFactor = (collateralValue * params.lltv) / pos.borrowBalance;\n                        pos.isHealthy = pos.healthFactor >= 1e18;\n                    } else {\n                        pos.healthFactor = type(uint256).max;\n                        pos.isHealthy = true;\n                    }\n                }\n            } catch {\n                // Oracle failed, leave values as 0\n            }\n        } else if (pos.borrowBalance == 0) {\n            pos.healthFactor = type(uint256).max;\n            pos.isHealthy = true;\n        }\n    }\n\n    /// @notice Get positions for a user across all registered markets\n    function getAllPositions(address user) external view returns (UserPosition[] memory positions) {\n        uint256 count = 0;\n        \n        // First pass: count non-empty positions\n        for (uint256 i = 0; i < _registeredMarketIds.length; i++) {\n            bytes32 marketId = _registeredMarketIds[i];\n            Position memory pos = morpho.position(marketId, user);\n            if (pos.collateral > 0 || pos.borrowShares > 0 || pos.supplyShares > 0) {\n                count++;\n            }\n        }\n\n        positions = new UserPosition[](count);\n        uint256 idx = 0;\n\n        // Second pass: populate positions\n        for (uint256 i = 0; i < _registeredMarketIds.length; i++) {\n            bytes32 marketId = _registeredMarketIds[i];\n            Position memory rawPos = morpho.position(marketId, user);\n            \n            if (rawPos.collateral > 0 || rawPos.borrowShares > 0 || rawPos.supplyShares > 0) {\n                MarketParams memory params = _marketParams[marketId];\n                positions[idx] = this.getPosition(params, user);\n                idx++;\n            }\n        }\n    }\n\n    /// @notice Get positions for specific markets\n    function getPositionsForMarkets(\n        MarketParams[] calldata paramsList,\n        address user\n    ) external view returns (UserPosition[] memory positions) {\n        positions = new UserPosition[](paramsList.length);\n        for (uint256 i = 0; i < paramsList.length; i++) {\n            positions[i] = this.getPosition(paramsList[i], user);\n        }\n    }\n\n    // ============ Market Info Queries ============\n\n    /// @notice Get comprehensive info for a single market\n    function getMarketInfo(MarketParams calldata params) external view returns (MarketInfo memory info) {\n        bytes32 marketId = params.id();\n        Market memory mkt = morpho.market(marketId);\n\n        info.marketId = marketId;\n        info.loanToken = params.loanToken;\n        info.collateralToken = params.collateralToken;\n        info.loanDecimals = _getDecimals(params.loanToken);\n        info.collateralDecimals = _getDecimals(params.collateralToken);\n        info.loanSymbol = _getSymbol(params.loanToken);\n        info.collateralSymbol = _getSymbol(params.collateralToken);\n        info.lltv = params.lltv;\n        info.totalSupplyAssets = mkt.totalSupplyAssets;\n        info.totalBorrowAssets = mkt.totalBorrowAssets;\n\n        if (mkt.totalSupplyAssets > 0) {\n            info.utilizationRate = (uint256(mkt.totalBorrowAssets) * 1e18) / uint256(mkt.totalSupplyAssets);\n        }\n\n        // Get oracle price\n        if (params.oracle != address(0)) {\n            try IMorphoOracle(params.oracle).price() returns (uint256 p) {\n                info.oraclePrice = p;\n            } catch {}\n        }\n\n        // Get rates\n        info.borrowRate = this.getBorrowApr(params);\n        info.supplyRate = this.getSupplyApr(params);\n    }\n\n    /// @notice Get info for all registered markets\n    function getAllMarketsInfo() external view returns (MarketInfo[] memory infos) {\n        infos = new MarketInfo[](_registeredMarketIds.length);\n        for (uint256 i = 0; i < _registeredMarketIds.length; i++) {\n            MarketParams memory params = _marketParams[_registeredMarketIds[i]];\n            infos[i] = this.getMarketInfo(params);\n        }\n    }\n\n    /// @notice Get market config data (similar to Aave's getReserveConfigs)\n    function getMarketConfigs(MarketParams[] calldata paramsList) external view returns (MarketConfigData[] memory configs) {\n        configs = new MarketConfigData[](paramsList.length);\n        \n        for (uint256 i = 0; i < paramsList.length; i++) {\n            MarketParams calldata params = paramsList[i];\n            bytes32 marketId = params.id();\n            Market memory mkt = morpho.market(marketId);\n\n            configs[i].marketId = marketId;\n            configs[i].loanToken = params.loanToken;\n            configs[i].collateralToken = params.collateralToken;\n            configs[i].lltv = params.lltv;\n            configs[i].loanDecimals = _getDecimals(params.loanToken);\n            configs[i].collateralDecimals = _getDecimals(params.collateralToken);\n            configs[i].isActive = mkt.totalSupplyAssets > 0;\n\n            if (params.oracle != address(0)) {\n                try IMorphoOracle(params.oracle).price() returns (uint256 p) {\n                    configs[i].oraclePrice = p;\n                } catch {}\n            }\n        }\n    }\n\n    // ============ Authorization ============\n\n    /// @notice Check if a user is authorized to act on behalf of another\n    function isAuthorized(address authorizer, address authorized) external view returns (bool) {\n        return morpho.isAuthorized(authorizer, authorized);\n    }\n\n    // ============ Utility ============\n\n    /// @notice Compute market ID from params\n    function computeMarketId(MarketParams calldata params) external pure returns (bytes32) {\n        return params.id();\n    }\n\n    /// @notice Get number of registered markets\n    function registeredMarketCount() external view returns (uint256) {\n        return _registeredMarketIds.length;\n    }\n\n    // ============ Internal Helpers ============\n\n    function _getDecimals(address token) internal view returns (uint8) {\n        try IERC20Metadata(token).decimals() returns (uint8 d) {\n            return d;\n        } catch {\n            return 18;\n        }\n    }\n\n    function _getSymbol(address token) internal view returns (string memory) {\n        try IERC20Metadata(token).symbol() returns (string memory s) {\n            return s;\n        } catch {\n            return \"\";\n        }\n    }\n}\n"
    },
    "contracts/v2/interfaces/morpho/IMorphoBlue.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/// @title IMorphoBlue Interface\n/// @notice Interface for Morpho Blue lending protocol\n/// @dev See https://github.com/morpho-org/morpho-blue\n\nstruct MarketParams {\n    address loanToken;\n    address collateralToken;\n    address oracle;\n    address irm;\n    uint256 lltv;\n}\n\nstruct Market {\n    uint128 totalSupplyAssets;\n    uint128 totalSupplyShares;\n    uint128 totalBorrowAssets;\n    uint128 totalBorrowShares;\n    uint128 lastUpdate;\n    uint128 fee;\n}\n\nstruct Position {\n    uint256 supplyShares;\n    uint128 borrowShares;\n    uint128 collateral;\n}\n\ninterface IMorphoBlue {\n    /// @notice The state of a market (by id)\n    function market(bytes32 id) external view returns (Market memory);\n\n    /// @notice The position of a user in a market\n    function position(bytes32 id, address user) external view returns (Position memory);\n\n    /// @notice Whether an address is authorized to act on behalf of another\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\n\n    /// @notice The nonce of an authorizer for EIP-712 signatures\n    function nonce(address authorizer) external view returns (uint256);\n\n    /// @notice Compute market ID from market params\n    function idToMarketParams(bytes32 id) external view returns (MarketParams memory);\n\n    // ============ Write Functions ============\n\n    /// @notice Supply assets to a market (lender side - earns yield)\n    /// @param marketParams The market to supply to\n    /// @param assets The amount of assets to supply (use 0 if using shares)\n    /// @param shares The amount of shares to mint (use 0 if using assets)\n    /// @param onBehalf The address to supply on behalf of\n    /// @param data Callback data (empty for no callback)\n    /// @return assetsSupplied The actual amount of assets supplied\n    /// @return sharesSupplied The actual amount of shares minted\n    function supply(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\n\n    /// @notice Withdraw assets from a market (lender side)\n    /// @param marketParams The market to withdraw from\n    /// @param assets The amount of assets to withdraw (use 0 if using shares)\n    /// @param shares The amount of shares to burn (use 0 if using assets)\n    /// @param onBehalf The address to withdraw on behalf of\n    /// @param receiver The address to receive the withdrawn assets\n    /// @return assetsWithdrawn The actual amount of assets withdrawn\n    /// @return sharesWithdrawn The actual amount of shares burned\n    function withdraw(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\n\n    /// @notice Borrow assets from a market\n    /// @param marketParams The market to borrow from\n    /// @param assets The amount of assets to borrow (use 0 if using shares)\n    /// @param shares The amount of borrow shares to mint (use 0 if using assets)\n    /// @param onBehalf The address to borrow on behalf of\n    /// @param receiver The address to receive the borrowed assets\n    /// @return assetsBorrowed The actual amount of assets borrowed\n    /// @return sharesBorrowed The actual amount of borrow shares minted\n    function borrow(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        address receiver\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\n\n    /// @notice Repay borrowed assets\n    /// @param marketParams The market to repay to\n    /// @param assets The amount of assets to repay (use 0 if using shares)\n    /// @param shares The amount of borrow shares to burn (use 0 if using assets)\n    /// @param onBehalf The address to repay on behalf of\n    /// @param data Callback data (empty for no callback)\n    /// @return assetsRepaid The actual amount of assets repaid\n    /// @return sharesRepaid The actual amount of borrow shares burned\n    function repay(\n        MarketParams memory marketParams,\n        uint256 assets,\n        uint256 shares,\n        address onBehalf,\n        bytes memory data\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\n\n    /// @notice Supply collateral to a market\n    /// @param marketParams The market to supply collateral to\n    /// @param assets The amount of collateral assets to supply\n    /// @param onBehalf The address to supply on behalf of\n    /// @param data Callback data (empty for no callback)\n    function supplyCollateral(\n        MarketParams memory marketParams,\n        uint256 assets,\n        address onBehalf,\n        bytes memory data\n    ) external;\n\n    /// @notice Withdraw collateral from a market\n    /// @param marketParams The market to withdraw collateral from\n    /// @param assets The amount of collateral assets to withdraw\n    /// @param onBehalf The address to withdraw on behalf of\n    /// @param receiver The address to receive the withdrawn collateral\n    function withdrawCollateral(\n        MarketParams memory marketParams,\n        uint256 assets,\n        address onBehalf,\n        address receiver\n    ) external;\n\n    /// @notice Set authorization for an address to act on behalf of the caller\n    /// @param authorized The address to authorize/deauthorize\n    /// @param newIsAuthorized Whether to authorize (true) or deauthorize (false)\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\n\n    /// @notice Set authorization with signature (EIP-712)\n    function setAuthorizationWithSig(\n        address authorizer,\n        address authorized,\n        bool newIsAuthorized,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /// @notice Accrue interest for a market\n    function accrueInterest(MarketParams memory marketParams) external;\n}\n\n/// @notice Library for computing Morpho Blue market IDs\nlibrary MorphoLib {\n    /// @notice Compute the market ID from market params\n    function id(MarketParams memory params) internal pure returns (bytes32) {\n        return keccak256(abi.encode(params));\n    }\n}\n\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}